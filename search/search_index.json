{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction to MicroTBX MicroTBX is an open source Microcontroller ToolBoX consisting of software components commonly needed in embedded software applications. Think of it as a Swiss army knife for your firmware. MicroTBX is written in the C programming language (C99). It currently supports all microcontrollers based on an ARM Cortex-M core, for example: ST STM32, Infineon XMC, and NXP S32K. There is little effort involved with porting MicroTBX to different microcontroller families. While developing MicroTBX, special care was given to making the code threadsafe. Access to shared resources are serialized with the help of critical sections . This make it safe to use MicroTBX in a multithreaded environment, for example when your embedded software program is built upon a pre-emptive RTOS. If you do not feel like reinventing the wheel, consider using MicroTBX. Ideally, MicroTBX is integrated into your embedded software program at the start of each new project. The following image illustrates where MicroTBX fits into your firmware's architecture: Components The following table presents an overview of the currently supported software components inside MicroTBX: Name Description Assertions For checking situations that should never happen. Critical Sections For mutual exclusive access to shared resources. Heap For static memory pre-allocation on the heap. Memory Pools For pool based dynamic memory allocation on the heap. Linked Lists For dynamically sized lists of data items. Random Numbers For generating random numbers. Checksums For calculating data checksums. Cryptography For data encryption and decryption. Platform For platform specifics. MISRA MicroTBX was developed with MISRA-C compliance in mind. This is a software development standard to facilitate best practices for programming safety-critical software in road vehicles and other embedded systems. Integration Adding MicroTBX to your software project is a simple five step process: Copy all the files from the source and the correct source/port/XXX port directory to your project. Copy the source/template/tbx_conf.h template configuration file to your project Configure your project such that the added .c files are compiled and linked during a build. Add the directories that contain the .h files to your compiler's include search path. Customize the MicroTBX configuration in tbx_conf.h , if desired. Alternatively, when you use CMake to manage your project's the build environment, you can use add_subdirectory() to register the MicroTBX interface library and add the desired libraries to your project's target_link_libraries() . A minimal CMakeLists.txt example follows, which assumes that: You copied MicroTBX to directory third_party/microtbx . You copied source/template/tbx_conf.h to the same directory as where your main.c resides. You are using an ARM Cortex-M based microcontroller. project(MyProject) add_subdirectory(third_party/microtbx) add_executable(MyProject main.c ) target_link_libraries(MyProject microtbx microtbx-cortexm ) Usage Add the following line to each source-file, where you intend to make use of MicroTBX: #include <microtbx.h> Licensing MicroTBX is licensed under the MIT license . This permissive license enables you to include and distribute MicroTBX with your firmware, even if it is proprietary. The only requirements are that you include a copy of the MIT license and do not change the copyright notice, when you distribute MicroTBX.","title":"Home"},{"location":"#introduction-to-microtbx","text":"MicroTBX is an open source Microcontroller ToolBoX consisting of software components commonly needed in embedded software applications. Think of it as a Swiss army knife for your firmware. MicroTBX is written in the C programming language (C99). It currently supports all microcontrollers based on an ARM Cortex-M core, for example: ST STM32, Infineon XMC, and NXP S32K. There is little effort involved with porting MicroTBX to different microcontroller families. While developing MicroTBX, special care was given to making the code threadsafe. Access to shared resources are serialized with the help of critical sections . This make it safe to use MicroTBX in a multithreaded environment, for example when your embedded software program is built upon a pre-emptive RTOS. If you do not feel like reinventing the wheel, consider using MicroTBX. Ideally, MicroTBX is integrated into your embedded software program at the start of each new project. The following image illustrates where MicroTBX fits into your firmware's architecture:","title":"Introduction to MicroTBX"},{"location":"#components","text":"The following table presents an overview of the currently supported software components inside MicroTBX: Name Description Assertions For checking situations that should never happen. Critical Sections For mutual exclusive access to shared resources. Heap For static memory pre-allocation on the heap. Memory Pools For pool based dynamic memory allocation on the heap. Linked Lists For dynamically sized lists of data items. Random Numbers For generating random numbers. Checksums For calculating data checksums. Cryptography For data encryption and decryption. Platform For platform specifics.","title":"Components"},{"location":"#misra","text":"MicroTBX was developed with MISRA-C compliance in mind. This is a software development standard to facilitate best practices for programming safety-critical software in road vehicles and other embedded systems.","title":"MISRA"},{"location":"#integration","text":"Adding MicroTBX to your software project is a simple five step process: Copy all the files from the source and the correct source/port/XXX port directory to your project. Copy the source/template/tbx_conf.h template configuration file to your project Configure your project such that the added .c files are compiled and linked during a build. Add the directories that contain the .h files to your compiler's include search path. Customize the MicroTBX configuration in tbx_conf.h , if desired. Alternatively, when you use CMake to manage your project's the build environment, you can use add_subdirectory() to register the MicroTBX interface library and add the desired libraries to your project's target_link_libraries() . A minimal CMakeLists.txt example follows, which assumes that: You copied MicroTBX to directory third_party/microtbx . You copied source/template/tbx_conf.h to the same directory as where your main.c resides. You are using an ARM Cortex-M based microcontroller. project(MyProject) add_subdirectory(third_party/microtbx) add_executable(MyProject main.c ) target_link_libraries(MyProject microtbx microtbx-cortexm )","title":"Integration"},{"location":"#usage","text":"Add the following line to each source-file, where you intend to make use of MicroTBX: #include <microtbx.h>","title":"Usage"},{"location":"#licensing","text":"MicroTBX is licensed under the MIT license . This permissive license enables you to include and distribute MicroTBX with your firmware, even if it is proprietary. The only requirements are that you include a copy of the MIT license and do not change the copyright notice, when you distribute MicroTBX.","title":"Licensing"},{"location":"apiref/","text":"API reference This section provides a full reference of all the functions, macros and types that MicroTBX offers. Macros Generic Macro Description TBX_VERSION_MAIN Main version number of MicroTBX. TBX_VERSION_MINOR Minor version number of MicroTBX. TBX_VERSION_PATCH Patch number of MicroTBX. TBX_TRUE Boolean true value. TBX_FALSE Boolean false value. TBX_OK Generic okay value. TBX_ERROR Generic error value. TBX_ON Generic on value. TBX_OFF Generic off value. TBX_UNUSED_ARG() Function-like macro to flag a function parameter as unused. TBX_ASSERT() Function-like macro to perform an assertion check. Configuration Macro Description TBX_CONF_HEAP_SIZE Configure the size of the heap in bytes. TBX_CONF_ASSERTIONS_ENABLE Enable/disable run-time assertions. Types tTbxAssertHandler typedef void (* tTbxAssertHandler)(char const * const file, uint32_t line) Function type for a run-time assertion handler function. tTbxRandomSeedInitHandler typedef uint32_t (* tTbxRandomSeedInitHandler)(void) Function type for an application specific seed initialization handler. tTbxList typedef struct tTbxList Layout of a linked list. Its pointer serves as the handle to the linked list which is obtained after creation of the list and which is needed in the other functions of this module. Note that its elements should be considered private and only be accessed internally by the linked list module. tTbxListCompareItems typedef uint8_t (* tTbxListCompareItems)(void const * item1, void const * item2) Callback function to compare items. It is called during list sorting. The return value of the callback function has the following meaning: TBX_TRUE if item1 's data is greater than item2 's data, TBX_FALSE otherwise. Functions Assertions More information regarding this software component, including code examples, is found here . TbxAssertSetHandler void TbxAssertSetHandler(tTbxAssertHandler assertHandler) Sets the application specific assertion handler. Use macro TBX_ASSERT() in your code for assertions. Param Description assertHandler Pointer to the application specific assertion handler to use instead of the default internal handler. The type is tTbxAssertHandler . Critical Sections More information regarding this software component, including code examples, is found here . TbxCriticalSectionEnter void TbxCriticalSectionEnter(void) Enter a critical section. Critical sections are needed in an interrupt driven software program to obtain mutual exclusive access shared resources such as global data and certain peripherals. Note that each call to this function should always be followed by a call to TbxCriticalSectionExit() . TbxCriticalSectionExit void TbxCriticalSectionExit(void) Exit a critical section. Critical sections are needed in an interrupt driven software program to obtain mutual exclusive access shared resources such as global data and certain peripherals. Note that each call to this function should always be preceded by a call to TbxCriticalSectionEnter() . Heap More information regarding this software component, including code examples, is found here . TbxHeapAllocate void * TbxHeapAllocate(size_t size) Allocates the desired number of bytes on the heap. It can be used instead of the compiler specific malloc() function. Note that free-ing of allocated memory is not supported to prevent memory fragmentation. If you want to dynamically allocate and release memory, use memory pools . Note that you configure the overall heap size with macro TBX_CONF_HEAP_SIZE in tbx_conf.h . Parameter Description size The number of bytes to allocate on the heap. Return value Pointer to the start of the newly allocated heap memory if successful, NULL otherwise. TbxHeapGetFree size_t TbxHeapGetFree(void) Obtains the current amount of bytes that are still available on the heap. Return value Number of free bytes on the heap. Memory Pools More information regarding this software component, including code examples, is found here . TbxMemPoolCreate uint8_t TbxMemPoolCreate(size_t numBlocks, size_t blockSize) Creates a new memory pool with the specified number of blocks, where each block has the size as specified by the second function parameter. The required memory is statically preallocated on the heap. This function is typically called one or more times during software program initialization, before the infinite program loop is entered. Once one ore more memory pools were created, the functions TbxMemPoolAllocate() and TbxMemPoolRelease() can be called to perform dynamic memory allocation. A well designed memory pool approach makes dynamic memory allocation possible on RAM constrained microcontrollers, without the need to worry about memory fragmentation. Note that deleting a previously created memory pool is not supported on purpose to prevent memory fragmentation. When this function is called to create a memory pool with a size that was already created before, the already existing memory pool is extended instead of creating a new memory pool. This is an important feature because it makes it possible to automatically expand the memory pool if more blocks are needed. Parameter Description numBlocks The number of blocks to statically preallocate on the heap for this memory pool. blockSize The size of each block in bytes. Return value TBX_OK if successful, TBX_ERROR otherwise for example when there is no more space available on the heap to statically preallocated the blocks. TbxMemPoolAllocate void * TbxMemPoolAllocate(size_t size) Attempts to allocate the desired number of bytes in a previously created memory pool. A block will be allocated in a memory pool that best fits the requested byte size. For example, if the following memory pools were created during program initialization: TbxMemPoolCreate(10, 8); TbxMemPoolCreate(10, 16); TbxMemPoolCreate(10, 32); And the following function call is made: uint8_t * myMem = TbxMemPoolAllocate(9); Then the memory will be allocated from the memory pool with block size 16, so the second memory pool that was created. If there are no more blocks available in that memory pool, then NULL is returned. So note that this function does NOT move on to the memory pool with one block size larger. Such a feature would be easy to realize but this design decision was made on purpose. Parameter Description size The number of bytes to allocate in a memory pool. Return value Pointer to the start of the newly allocated memory if successful, NULL otherwise. TbxMemPoolAllocateAuto void * TbxMemPoolAllocateAuto(size_t size) An alternative version of TbxMemPoolAllocate() , which automatically creates a new memory pool with one block, if one with the exact same blockSize was not yet created. If one with the exact same blockSize was already created, but it's full, then the memory pool is automatically expanded to have one more block. This offers a convenient way of working with memory pools compared to TbxMemPoolAllocate() . In addition, it guarantees that it always works on a memory pool where the blockSize == \"size\" . It bypasses the best fitting algorithm used by TbxMemPoolAllocate() , which looks for an existing memory pool with a blockSize >= \"size\" . For example, to allocate two blocks of 32 bytes using memory pools, all you need to do is: uint8_t * myMem[2]; myMem[0] = TbxMemPoolAllocateAuto(32); myMem[1] = TbxMemPoolAllocateAuto(32); Note that there was no need to first create this memory pool with a call to TbxMemPoolCreate() . During the first call to TbxMemPoolAllocateAuto() , the memory pool with a block size of 32 bytes was automatically created, including adding one block of 32 bytes to it, which was immediately allocated. During the second call to TbxMemPoolAllocateAuto() , another block of 32 bytes was automatically added to the existing memory pool and the newly added block was immediately allocated. Parameter Description size The number of bytes to allocate using a memory pool. Return value Pointer to the start of the newly allocated memory if successful, NULL otherwise. TbxMemPoolRelease void TbxMemPoolRelease(void * memPtr) Releases the previously allocated block of memory. Once the memory is released, it can be allocated again afterwards with function TbxMemPoolAllocate() . Note that this function automatically finds the memory pool that the memory block belongs to. Parameter Description memPtr Pointer to the start of the memory block. Basically, the pointer that was returned by function TbxMemPoolAllocate() , when the memory was initially allocated. Linked Lists More information regarding this software component, including code examples, is found here . TbxListCreate tTbxList * TbxListCreate(void) Creates a new and empty linked list and returns its pointer. Make sure to store the pointer because it serves as a handle to the linked list, which is needed when calling the other API functions in this module. Return value The pointer to the created linked list or NULL in case or error. The type is tTbxList . TbxListDelete void TbxListDelete(tTbxList * list) Deletes a previously created linked list. Afterwards, the pointer to the linked list is no longer valid and should not be used anymore. Parameter Description list Pointer to a previously created linked list to operate on. TbxListClear void TbxListClear(tTbxList * list) Removes all items from the linked list. Keep in mind that it is the caller's responsibility to release the memory of the items that were placed in the list, before calling this function. Parameter Description list Pointer to a previously created linked list to operate on. TbxListGetSize size_t TbxListGetSize(tTbxList const * list) Obtains the number of items that are currently stored in the list. Parameter Description list Pointer to a previously created linked list to operate on. Return values Total number of items currently stored in the list. TbxListInsertItemFront uint8_t TbxListInsertItemFront(tTbxList * list, void * item) Inserts an item into the list. The item will be added at the start of the list. Parameter Description list Pointer to a previously created linked list to operate on. item Pointer to the item to insert. Return value TBX_OK if the item could be inserted, TBX_ERROR otherwise. TbxListInsertItemBack uint8_t TbxListInsertItemBack(tTbxList * list, void * item) Inserts an item into the list. The item will be added at the end of the list. Parameter Description list Pointer to a previously created linked list to operate on. item Pointer to the item to insert. Return value TBX_OK if the item could be inserted, TBX_ERROR otherwise. TbxListInsertItemBefore uint8_t TbxListInsertItemBefore(tTbxList * list, void * item, void const * itemRef) Inserts an item into the list. The item will be added before the reference item. Only use this API function if the list does NOT contain items with a duplicate value, meaning items that point to the exact same memory address. Parameter Description list Pointer to a previously created linked list to operate on. item Pointer to the item to insert. itemRef Reference item before which the new item should be inserted. Return value TBX_OK if the item could be inserted, TBX_ERROR otherwise. TbxListInsertItemAfter uint8_t TbxListInsertItemAfter(tTbxList * list, void * item, void const * itemRef) Inserts an item into the list. The item will be added after the reference item. Only use this API function if the list does NOT contain items with a duplicate value, meaning items that point to the exact same memory address. Parameter Description list Pointer to a previously created linked list to operate on. item Pointer to the item to insert. itemRef Reference item after which the new item should be inserted. Return value TBX_OK if the item could be inserted, TBX_ERROR otherwise. TbxListRemoveItem void TbxListRemoveItem(tTbxList * list, void const * item) Removes an item from the list, if present. Keep in mind that it is the caller's responsibility to release the memory of the item that is being removed from the list, before calling this function. Only use this API function if the list does NOT contain items with a duplicate value, meaning items that point to the exact same memory address. Parameter Description list Pointer to a previously created linked list to operate on. item Pointer to the item to remove. TbxListGetFirstItem void * TbxListGetFirstItem(tTbxList const * list) Obtains the item that is located at the start of the list. Note that the item is just read, not removed. Parameter Description list Pointer to a previously created linked list to operate on. Return value The item at the start of the list or NULL if the list is empty. TbxListGetLastItem void * TbxListGetLastItem(tTbxList const * list) Obtains the item that is located at the end of the list. Note that the item is just read, not removed. Parameter Description list Pointer to a previously created linked list to operate on. Return value The item at the end of the list or NULL if the list is empty. TbxListGetPreviousItem void * TbxListGetPreviousItem(tTbxList const * list, void const * itemRef) Obtains the item that is located one position before in the list, relative to the item given in the parameter. Note that the item is just read, not removed. Only use this API function if the list does NOT contain items with a duplicate value, meaning items that point to the exact same memory address. Parameter Description list Pointer to a previously created linked list to operate on. itemRef The item that is the next one in the list relative to the one this function should return. Return value The item one position before in the list or NULL if there are no more items in the list before the item given in the parameter. TbxListGetNextItem void * TbxListGetNextItem(tTbxList const * list, void const * itemRef) Obtains the item that is located one position further down in the list, relative to the item given in the parameter. Note that the item is just read, not removed. Only use this API function if the list does NOT contain items with a duplicate value, meaning items that point to the exact same memory address. Parameter Description list Pointer to a previously created linked list to operate on. itemRef The item that is the previous one in the list relative to the one this function should return. Return value The item one position further down in the list or NULL if there are no more items in the list after the item given in the parameter. TbxListSwapItems void TbxListSwapItems(tTbxList const * list, void * item1, void * item2) Swaps the specified list items around. Only use this API function if the list does NOT contain items with a duplicate value, meaning items that point to the exact same memory address. Parameter Description list Pointer to a previously created linked list to operate on. item1 The first item for the swap operation. item2 The second item for the swap operation. TbxListSortItems void TbxListSortItems(tTbxList const * list, tTbxListCompareItems compareItemsFcn) Sorts the items in the list. While sorting, it calls the specified callback function which should do the actual comparison of the items. Parameter Description list Pointer to a previously created linked list to operate on. compareItemsFcn Callback function that does the item comparison. It is of type tTbxListCompareItems . Random Numbers More information regarding this software component, including code examples, is found here . TbxRandomNumberGet uint32_t TbxRandomNumberGet(void) Obtains a random number. Return value Value of the newly generated random number. TbxRandomSetSeedInitHandler void TbxRandomSetSeedInitHandler(tTbxRandomSeedInitHandler seedInitHandler) Sets the application specific function that should be called when the seed for the random number generation should be initialized. The actual seed value is not really important, as long as it is a value that is different every time the software program runs, so after each reset event. Here are a few different approaches that could be implemented to realize an seed value that is different each time the software program runs: Keep one of the analog inputs on your microcontroller unconnected. Such a floating analog input picks up noise from the surrounding environment and readings will therefore always vary slightly. Configure your ADC peripheral to perform an analog to digital conversion of this analog input and use its result value to seed the generator. If your microcontroller has EEPROM or a non-volatile register, you can use it to store a value that you use to seed the generator. Then simply increment its value by one upon software program startup. This way you have a different seed value every time your software program is started. Keep in mind though that these data storage options have a limited amount of write cycles. A better option might be to use external FRAM. If your microcontroller has access to an external file system such as an SD-card, you could store a value, which you use to seed the generator, in a file. Then simply increment its value by one upon software program startup. This way you have a different seed value every time your software program is started. If your microcontroller based system features a battery backed real-time clock, you could use the current date/time value to seed the generator algorithm. Parameter Description seedInitHandler Pointer to the application specific seed initialization handler to use instead of the default internal handler. If is of type tTbxRandomSeedInitHandler . Checksums More information regarding this software component, including code examples, is found here . TbxChecksumCrc16Calculate uint16_t TbxChecksumCrc16Calculate(uint8_t const * data, size_t len) Calculates a 16-bit CRC value over the specified data. Parameter Description data Array with bytes over which the CRC16 should be calculated. len Number of bytes in the data array. Return value The 16-bit CRC value. TbxChecksumCrc32Calculate uint32_t TbxChecksumCrc32Calculate(uint8_t const * data, size_t len) Calculates a 32-bit CRC value over the specified data. Parameter Description data Array with bytes over which the CRC32 should be calculated. len Number of bytes in the data array. Return value The 32-bit CRC value. Cryptography More information regarding this software component is, including code examples, found here . TbxCryptoAes256Encrypt void TbxCryptoAes256Encrypt(uint8_t * data, size_t len, uint8_t const * key) Encrypts the len-bytes in the specified data-array, using the specified 256-bit (32 bytes) key. The results are written back into the same array. Parameter Description data Pointer to the byte array with data to encrypt. The encrypted bytes are stored in the same array. len The number of bytes in the data-array to encrypt. It must be a multiple of 16, as this is the AES256 minimal block size. key The 256-bit encryption key as a array of 32 bytes. TbxCryptoAes256Decrypt void TbxCryptoAes256Decrypt(uint8_t * data, size_t len, uint8_t const * key) Decrypts the len-bytes in the specified data-array, using the specified 256-bit (32 bytes) key. The results are written back into the same array. Parameter Description data Pointer to the byte array with data to decrypt. The decrypted bytes are stored in the same array. len The number of bytes in the data-array to decrypt. It must be a multiple of 16, as this is the AES256 minimal block size. key The 256-bit decryption key as a array of 32 bytes. Platform More information regarding this software component is, including code examples, found here . TbxPlatformLittleEndian uint8_t TbxPlatformLittleEndian(void) Utility function to determine if the targets memory storage organization is little endian (Intel) or big endian (Motorola). Return value TBX_TRUE for little endian, TBX_FALSE for big endian.","title":"API reference"},{"location":"apiref/#api-reference","text":"This section provides a full reference of all the functions, macros and types that MicroTBX offers.","title":"API reference"},{"location":"apiref/#macros","text":"","title":"Macros"},{"location":"apiref/#generic","text":"Macro Description TBX_VERSION_MAIN Main version number of MicroTBX. TBX_VERSION_MINOR Minor version number of MicroTBX. TBX_VERSION_PATCH Patch number of MicroTBX. TBX_TRUE Boolean true value. TBX_FALSE Boolean false value. TBX_OK Generic okay value. TBX_ERROR Generic error value. TBX_ON Generic on value. TBX_OFF Generic off value. TBX_UNUSED_ARG() Function-like macro to flag a function parameter as unused. TBX_ASSERT() Function-like macro to perform an assertion check.","title":"Generic"},{"location":"apiref/#configuration","text":"Macro Description TBX_CONF_HEAP_SIZE Configure the size of the heap in bytes. TBX_CONF_ASSERTIONS_ENABLE Enable/disable run-time assertions.","title":"Configuration"},{"location":"apiref/#types","text":"","title":"Types"},{"location":"apiref/#ttbxasserthandler","text":"typedef void (* tTbxAssertHandler)(char const * const file, uint32_t line) Function type for a run-time assertion handler function.","title":"tTbxAssertHandler"},{"location":"apiref/#ttbxrandomseedinithandler","text":"typedef uint32_t (* tTbxRandomSeedInitHandler)(void) Function type for an application specific seed initialization handler.","title":"tTbxRandomSeedInitHandler"},{"location":"apiref/#ttbxlist","text":"typedef struct tTbxList Layout of a linked list. Its pointer serves as the handle to the linked list which is obtained after creation of the list and which is needed in the other functions of this module. Note that its elements should be considered private and only be accessed internally by the linked list module.","title":"tTbxList"},{"location":"apiref/#ttbxlistcompareitems","text":"typedef uint8_t (* tTbxListCompareItems)(void const * item1, void const * item2) Callback function to compare items. It is called during list sorting. The return value of the callback function has the following meaning: TBX_TRUE if item1 's data is greater than item2 's data, TBX_FALSE otherwise.","title":"tTbxListCompareItems"},{"location":"apiref/#functions","text":"","title":"Functions"},{"location":"apiref/#assertions","text":"More information regarding this software component, including code examples, is found here .","title":"Assertions"},{"location":"apiref/#tbxassertsethandler","text":"void TbxAssertSetHandler(tTbxAssertHandler assertHandler) Sets the application specific assertion handler. Use macro TBX_ASSERT() in your code for assertions. Param Description assertHandler Pointer to the application specific assertion handler to use instead of the default internal handler. The type is tTbxAssertHandler .","title":"TbxAssertSetHandler"},{"location":"apiref/#critical-sections","text":"More information regarding this software component, including code examples, is found here .","title":"Critical Sections"},{"location":"apiref/#tbxcriticalsectionenter","text":"void TbxCriticalSectionEnter(void) Enter a critical section. Critical sections are needed in an interrupt driven software program to obtain mutual exclusive access shared resources such as global data and certain peripherals. Note that each call to this function should always be followed by a call to TbxCriticalSectionExit() .","title":"TbxCriticalSectionEnter"},{"location":"apiref/#tbxcriticalsectionexit","text":"void TbxCriticalSectionExit(void) Exit a critical section. Critical sections are needed in an interrupt driven software program to obtain mutual exclusive access shared resources such as global data and certain peripherals. Note that each call to this function should always be preceded by a call to TbxCriticalSectionEnter() .","title":"TbxCriticalSectionExit"},{"location":"apiref/#heap","text":"More information regarding this software component, including code examples, is found here .","title":"Heap"},{"location":"apiref/#tbxheapallocate","text":"void * TbxHeapAllocate(size_t size) Allocates the desired number of bytes on the heap. It can be used instead of the compiler specific malloc() function. Note that free-ing of allocated memory is not supported to prevent memory fragmentation. If you want to dynamically allocate and release memory, use memory pools . Note that you configure the overall heap size with macro TBX_CONF_HEAP_SIZE in tbx_conf.h . Parameter Description size The number of bytes to allocate on the heap. Return value Pointer to the start of the newly allocated heap memory if successful, NULL otherwise.","title":"TbxHeapAllocate"},{"location":"apiref/#tbxheapgetfree","text":"size_t TbxHeapGetFree(void) Obtains the current amount of bytes that are still available on the heap. Return value Number of free bytes on the heap.","title":"TbxHeapGetFree"},{"location":"apiref/#memory-pools","text":"More information regarding this software component, including code examples, is found here .","title":"Memory Pools"},{"location":"apiref/#tbxmempoolcreate","text":"uint8_t TbxMemPoolCreate(size_t numBlocks, size_t blockSize) Creates a new memory pool with the specified number of blocks, where each block has the size as specified by the second function parameter. The required memory is statically preallocated on the heap. This function is typically called one or more times during software program initialization, before the infinite program loop is entered. Once one ore more memory pools were created, the functions TbxMemPoolAllocate() and TbxMemPoolRelease() can be called to perform dynamic memory allocation. A well designed memory pool approach makes dynamic memory allocation possible on RAM constrained microcontrollers, without the need to worry about memory fragmentation. Note that deleting a previously created memory pool is not supported on purpose to prevent memory fragmentation. When this function is called to create a memory pool with a size that was already created before, the already existing memory pool is extended instead of creating a new memory pool. This is an important feature because it makes it possible to automatically expand the memory pool if more blocks are needed. Parameter Description numBlocks The number of blocks to statically preallocate on the heap for this memory pool. blockSize The size of each block in bytes. Return value TBX_OK if successful, TBX_ERROR otherwise for example when there is no more space available on the heap to statically preallocated the blocks.","title":"TbxMemPoolCreate"},{"location":"apiref/#tbxmempoolallocate","text":"void * TbxMemPoolAllocate(size_t size) Attempts to allocate the desired number of bytes in a previously created memory pool. A block will be allocated in a memory pool that best fits the requested byte size. For example, if the following memory pools were created during program initialization: TbxMemPoolCreate(10, 8); TbxMemPoolCreate(10, 16); TbxMemPoolCreate(10, 32); And the following function call is made: uint8_t * myMem = TbxMemPoolAllocate(9); Then the memory will be allocated from the memory pool with block size 16, so the second memory pool that was created. If there are no more blocks available in that memory pool, then NULL is returned. So note that this function does NOT move on to the memory pool with one block size larger. Such a feature would be easy to realize but this design decision was made on purpose. Parameter Description size The number of bytes to allocate in a memory pool. Return value Pointer to the start of the newly allocated memory if successful, NULL otherwise.","title":"TbxMemPoolAllocate"},{"location":"apiref/#tbxmempoolallocateauto","text":"void * TbxMemPoolAllocateAuto(size_t size) An alternative version of TbxMemPoolAllocate() , which automatically creates a new memory pool with one block, if one with the exact same blockSize was not yet created. If one with the exact same blockSize was already created, but it's full, then the memory pool is automatically expanded to have one more block. This offers a convenient way of working with memory pools compared to TbxMemPoolAllocate() . In addition, it guarantees that it always works on a memory pool where the blockSize == \"size\" . It bypasses the best fitting algorithm used by TbxMemPoolAllocate() , which looks for an existing memory pool with a blockSize >= \"size\" . For example, to allocate two blocks of 32 bytes using memory pools, all you need to do is: uint8_t * myMem[2]; myMem[0] = TbxMemPoolAllocateAuto(32); myMem[1] = TbxMemPoolAllocateAuto(32); Note that there was no need to first create this memory pool with a call to TbxMemPoolCreate() . During the first call to TbxMemPoolAllocateAuto() , the memory pool with a block size of 32 bytes was automatically created, including adding one block of 32 bytes to it, which was immediately allocated. During the second call to TbxMemPoolAllocateAuto() , another block of 32 bytes was automatically added to the existing memory pool and the newly added block was immediately allocated. Parameter Description size The number of bytes to allocate using a memory pool. Return value Pointer to the start of the newly allocated memory if successful, NULL otherwise.","title":"TbxMemPoolAllocateAuto"},{"location":"apiref/#tbxmempoolrelease","text":"void TbxMemPoolRelease(void * memPtr) Releases the previously allocated block of memory. Once the memory is released, it can be allocated again afterwards with function TbxMemPoolAllocate() . Note that this function automatically finds the memory pool that the memory block belongs to. Parameter Description memPtr Pointer to the start of the memory block. Basically, the pointer that was returned by function TbxMemPoolAllocate() , when the memory was initially allocated.","title":"TbxMemPoolRelease"},{"location":"apiref/#linked-lists","text":"More information regarding this software component, including code examples, is found here .","title":"Linked Lists"},{"location":"apiref/#tbxlistcreate","text":"tTbxList * TbxListCreate(void) Creates a new and empty linked list and returns its pointer. Make sure to store the pointer because it serves as a handle to the linked list, which is needed when calling the other API functions in this module. Return value The pointer to the created linked list or NULL in case or error. The type is tTbxList .","title":"TbxListCreate"},{"location":"apiref/#tbxlistdelete","text":"void TbxListDelete(tTbxList * list) Deletes a previously created linked list. Afterwards, the pointer to the linked list is no longer valid and should not be used anymore. Parameter Description list Pointer to a previously created linked list to operate on.","title":"TbxListDelete"},{"location":"apiref/#tbxlistclear","text":"void TbxListClear(tTbxList * list) Removes all items from the linked list. Keep in mind that it is the caller's responsibility to release the memory of the items that were placed in the list, before calling this function. Parameter Description list Pointer to a previously created linked list to operate on.","title":"TbxListClear"},{"location":"apiref/#tbxlistgetsize","text":"size_t TbxListGetSize(tTbxList const * list) Obtains the number of items that are currently stored in the list. Parameter Description list Pointer to a previously created linked list to operate on. Return values Total number of items currently stored in the list.","title":"TbxListGetSize"},{"location":"apiref/#tbxlistinsertitemfront","text":"uint8_t TbxListInsertItemFront(tTbxList * list, void * item) Inserts an item into the list. The item will be added at the start of the list. Parameter Description list Pointer to a previously created linked list to operate on. item Pointer to the item to insert. Return value TBX_OK if the item could be inserted, TBX_ERROR otherwise.","title":"TbxListInsertItemFront"},{"location":"apiref/#tbxlistinsertitemback","text":"uint8_t TbxListInsertItemBack(tTbxList * list, void * item) Inserts an item into the list. The item will be added at the end of the list. Parameter Description list Pointer to a previously created linked list to operate on. item Pointer to the item to insert. Return value TBX_OK if the item could be inserted, TBX_ERROR otherwise.","title":"TbxListInsertItemBack"},{"location":"apiref/#tbxlistinsertitembefore","text":"uint8_t TbxListInsertItemBefore(tTbxList * list, void * item, void const * itemRef) Inserts an item into the list. The item will be added before the reference item. Only use this API function if the list does NOT contain items with a duplicate value, meaning items that point to the exact same memory address. Parameter Description list Pointer to a previously created linked list to operate on. item Pointer to the item to insert. itemRef Reference item before which the new item should be inserted. Return value TBX_OK if the item could be inserted, TBX_ERROR otherwise.","title":"TbxListInsertItemBefore"},{"location":"apiref/#tbxlistinsertitemafter","text":"uint8_t TbxListInsertItemAfter(tTbxList * list, void * item, void const * itemRef) Inserts an item into the list. The item will be added after the reference item. Only use this API function if the list does NOT contain items with a duplicate value, meaning items that point to the exact same memory address. Parameter Description list Pointer to a previously created linked list to operate on. item Pointer to the item to insert. itemRef Reference item after which the new item should be inserted. Return value TBX_OK if the item could be inserted, TBX_ERROR otherwise.","title":"TbxListInsertItemAfter"},{"location":"apiref/#tbxlistremoveitem","text":"void TbxListRemoveItem(tTbxList * list, void const * item) Removes an item from the list, if present. Keep in mind that it is the caller's responsibility to release the memory of the item that is being removed from the list, before calling this function. Only use this API function if the list does NOT contain items with a duplicate value, meaning items that point to the exact same memory address. Parameter Description list Pointer to a previously created linked list to operate on. item Pointer to the item to remove.","title":"TbxListRemoveItem"},{"location":"apiref/#tbxlistgetfirstitem","text":"void * TbxListGetFirstItem(tTbxList const * list) Obtains the item that is located at the start of the list. Note that the item is just read, not removed. Parameter Description list Pointer to a previously created linked list to operate on. Return value The item at the start of the list or NULL if the list is empty.","title":"TbxListGetFirstItem"},{"location":"apiref/#tbxlistgetlastitem","text":"void * TbxListGetLastItem(tTbxList const * list) Obtains the item that is located at the end of the list. Note that the item is just read, not removed. Parameter Description list Pointer to a previously created linked list to operate on. Return value The item at the end of the list or NULL if the list is empty.","title":"TbxListGetLastItem"},{"location":"apiref/#tbxlistgetpreviousitem","text":"void * TbxListGetPreviousItem(tTbxList const * list, void const * itemRef) Obtains the item that is located one position before in the list, relative to the item given in the parameter. Note that the item is just read, not removed. Only use this API function if the list does NOT contain items with a duplicate value, meaning items that point to the exact same memory address. Parameter Description list Pointer to a previously created linked list to operate on. itemRef The item that is the next one in the list relative to the one this function should return. Return value The item one position before in the list or NULL if there are no more items in the list before the item given in the parameter.","title":"TbxListGetPreviousItem"},{"location":"apiref/#tbxlistgetnextitem","text":"void * TbxListGetNextItem(tTbxList const * list, void const * itemRef) Obtains the item that is located one position further down in the list, relative to the item given in the parameter. Note that the item is just read, not removed. Only use this API function if the list does NOT contain items with a duplicate value, meaning items that point to the exact same memory address. Parameter Description list Pointer to a previously created linked list to operate on. itemRef The item that is the previous one in the list relative to the one this function should return. Return value The item one position further down in the list or NULL if there are no more items in the list after the item given in the parameter.","title":"TbxListGetNextItem"},{"location":"apiref/#tbxlistswapitems","text":"void TbxListSwapItems(tTbxList const * list, void * item1, void * item2) Swaps the specified list items around. Only use this API function if the list does NOT contain items with a duplicate value, meaning items that point to the exact same memory address. Parameter Description list Pointer to a previously created linked list to operate on. item1 The first item for the swap operation. item2 The second item for the swap operation.","title":"TbxListSwapItems"},{"location":"apiref/#tbxlistsortitems","text":"void TbxListSortItems(tTbxList const * list, tTbxListCompareItems compareItemsFcn) Sorts the items in the list. While sorting, it calls the specified callback function which should do the actual comparison of the items. Parameter Description list Pointer to a previously created linked list to operate on. compareItemsFcn Callback function that does the item comparison. It is of type tTbxListCompareItems .","title":"TbxListSortItems"},{"location":"apiref/#random-numbers","text":"More information regarding this software component, including code examples, is found here .","title":"Random Numbers"},{"location":"apiref/#tbxrandomnumberget","text":"uint32_t TbxRandomNumberGet(void) Obtains a random number. Return value Value of the newly generated random number.","title":"TbxRandomNumberGet"},{"location":"apiref/#tbxrandomsetseedinithandler","text":"void TbxRandomSetSeedInitHandler(tTbxRandomSeedInitHandler seedInitHandler) Sets the application specific function that should be called when the seed for the random number generation should be initialized. The actual seed value is not really important, as long as it is a value that is different every time the software program runs, so after each reset event. Here are a few different approaches that could be implemented to realize an seed value that is different each time the software program runs: Keep one of the analog inputs on your microcontroller unconnected. Such a floating analog input picks up noise from the surrounding environment and readings will therefore always vary slightly. Configure your ADC peripheral to perform an analog to digital conversion of this analog input and use its result value to seed the generator. If your microcontroller has EEPROM or a non-volatile register, you can use it to store a value that you use to seed the generator. Then simply increment its value by one upon software program startup. This way you have a different seed value every time your software program is started. Keep in mind though that these data storage options have a limited amount of write cycles. A better option might be to use external FRAM. If your microcontroller has access to an external file system such as an SD-card, you could store a value, which you use to seed the generator, in a file. Then simply increment its value by one upon software program startup. This way you have a different seed value every time your software program is started. If your microcontroller based system features a battery backed real-time clock, you could use the current date/time value to seed the generator algorithm. Parameter Description seedInitHandler Pointer to the application specific seed initialization handler to use instead of the default internal handler. If is of type tTbxRandomSeedInitHandler .","title":"TbxRandomSetSeedInitHandler"},{"location":"apiref/#checksums","text":"More information regarding this software component, including code examples, is found here .","title":"Checksums"},{"location":"apiref/#tbxchecksumcrc16calculate","text":"uint16_t TbxChecksumCrc16Calculate(uint8_t const * data, size_t len) Calculates a 16-bit CRC value over the specified data. Parameter Description data Array with bytes over which the CRC16 should be calculated. len Number of bytes in the data array. Return value The 16-bit CRC value.","title":"TbxChecksumCrc16Calculate"},{"location":"apiref/#tbxchecksumcrc32calculate","text":"uint32_t TbxChecksumCrc32Calculate(uint8_t const * data, size_t len) Calculates a 32-bit CRC value over the specified data. Parameter Description data Array with bytes over which the CRC32 should be calculated. len Number of bytes in the data array. Return value The 32-bit CRC value.","title":"TbxChecksumCrc32Calculate"},{"location":"apiref/#cryptography","text":"More information regarding this software component is, including code examples, found here .","title":"Cryptography"},{"location":"apiref/#tbxcryptoaes256encrypt","text":"void TbxCryptoAes256Encrypt(uint8_t * data, size_t len, uint8_t const * key) Encrypts the len-bytes in the specified data-array, using the specified 256-bit (32 bytes) key. The results are written back into the same array. Parameter Description data Pointer to the byte array with data to encrypt. The encrypted bytes are stored in the same array. len The number of bytes in the data-array to encrypt. It must be a multiple of 16, as this is the AES256 minimal block size. key The 256-bit encryption key as a array of 32 bytes.","title":"TbxCryptoAes256Encrypt"},{"location":"apiref/#tbxcryptoaes256decrypt","text":"void TbxCryptoAes256Decrypt(uint8_t * data, size_t len, uint8_t const * key) Decrypts the len-bytes in the specified data-array, using the specified 256-bit (32 bytes) key. The results are written back into the same array. Parameter Description data Pointer to the byte array with data to decrypt. The decrypted bytes are stored in the same array. len The number of bytes in the data-array to decrypt. It must be a multiple of 16, as this is the AES256 minimal block size. key The 256-bit decryption key as a array of 32 bytes.","title":"TbxCryptoAes256Decrypt"},{"location":"apiref/#platform","text":"More information regarding this software component is, including code examples, found here .","title":"Platform"},{"location":"apiref/#tbxplatformlittleendian","text":"uint8_t TbxPlatformLittleEndian(void) Utility function to determine if the targets memory storage organization is little endian (Intel) or big endian (Motorola). Return value TBX_TRUE for little endian, TBX_FALSE for big endian.","title":"TbxPlatformLittleEndian"},{"location":"assertions/","text":"Assertions Assertions are statements used for checking situations that should never happen. It is a good coding practice to add such statements to your software program. For example to validate the values of function parameters, to check pointers for not being NULL, to check that an array index is not out of range, etc. Usage In MicroTBX, assertions are implemented with the TBX_ASSERT(argument) macro. The argument must evaluate to boolean true for the program to continue its execution as expected. If the argument evaluates to boolean false , an error is triggered. In this error case, MicroTBX jumps to an internal function with an infinite loop to hang the program. This function is called with two important parameters for debugging purposes: the filename of the source file that caused the assertion to fail and the line number inside this file where the assertion occurred. Practically, this means that when debugging and testing your software program, you simply set a breakpoint inside the internal function TbxAssertTrigger() . If an assertion is triggered, the debugger stops at the breakpoint. At this point you can inspect the function parameters file and line to determine which assertion statement caused the problem. Once you know the root cause of the assertion error, you can start working on a solution to fix the problem from happening in the future. In case you do not like the default assertion error handling, MicroTBX also makes it possible for you to configure your own assertion handler with function TbxAssertSetHandler() . For example to execute a printf statement, to turn on an LED, or to write assertion error info to a file an on SD-card to indicate that an assertion error was detected. Examples The following example demonstrates how assertions can be used to test that a function parameter has a valid value range: uint8_t myArray[4] = { 1, 2, 3, 4 }; void IncrementArrayElement(int8_t index) { /* Make sure the array index is positive. */ TBX_ASSERT(index >= 0); /* Make sure the array index is not out of range. */ TBX_ASSERT(index < (sizeof(myArray)/sizeof(myArray[0]))); /* Increment the array element at the requested index. */ myArray[index]++; } The next example shows how you can register your own assertion error handler, which overrides the internal error handling: #include <stdio.h> void MyAssertionHandler(const char * const file, uint32_t line) { /* Display the assertion error info. */ printf(\"[ERROR] Assertion in %s at line %lu\", file, line); } int main(void) { /* Register the application specific assertion handler. */ TbxAssertSetHandler(MyAssertionHandler); /* TODO Implement your program here. */ return 0; } Configuration The enable the assertion error handling, set the macro TBX_CONF_ASSERTIONS_ENABLE to a value of 1 : /** \\brief Enable/disable run-time assertions. */ #define TBX_CONF_ASSERTIONS_ENABLE (1U) To disable the assertion error handling, set this macro to a value of 0 . Note that there is not need to remove the TBX_ASSERT() macros from your code. MicroTBX automatically makes the TBX_ASSERT() macro and empty macro without side effect, when assertion error handling was disabled. Assertions are typically enabled in a debug version of the software program and disabled in a release version of the software program. Extra tips Make sure to write your assertion statements such that you do not accidentally remove functionality from your software program, after disabling the assertion error handling. So instead of the following: FATFS fs; void MountDrive(void) { /* Mount the drive and make sure the drive mounting succeeded. */ TBX_ASSERT(f_mount(&fs, \"0:\", 0) == FR_OK); } Do the following: FATFS fs; void MountDrive(void) { FRESULT fresult; /* Mount the drive. */ fresult = f_mount(&fs, \"0:\", 0); /* Make sure the drive mounting succeeded. */ TBX_ASSERT(fresult == FR_OK); } To be sure that the before mentioned problem does not occur, one could make the argument that assertion error handling should simply never be disabled.","title":"Assertions"},{"location":"assertions/#assertions","text":"Assertions are statements used for checking situations that should never happen. It is a good coding practice to add such statements to your software program. For example to validate the values of function parameters, to check pointers for not being NULL, to check that an array index is not out of range, etc.","title":"Assertions"},{"location":"assertions/#usage","text":"In MicroTBX, assertions are implemented with the TBX_ASSERT(argument) macro. The argument must evaluate to boolean true for the program to continue its execution as expected. If the argument evaluates to boolean false , an error is triggered. In this error case, MicroTBX jumps to an internal function with an infinite loop to hang the program. This function is called with two important parameters for debugging purposes: the filename of the source file that caused the assertion to fail and the line number inside this file where the assertion occurred. Practically, this means that when debugging and testing your software program, you simply set a breakpoint inside the internal function TbxAssertTrigger() . If an assertion is triggered, the debugger stops at the breakpoint. At this point you can inspect the function parameters file and line to determine which assertion statement caused the problem. Once you know the root cause of the assertion error, you can start working on a solution to fix the problem from happening in the future. In case you do not like the default assertion error handling, MicroTBX also makes it possible for you to configure your own assertion handler with function TbxAssertSetHandler() . For example to execute a printf statement, to turn on an LED, or to write assertion error info to a file an on SD-card to indicate that an assertion error was detected.","title":"Usage"},{"location":"assertions/#examples","text":"The following example demonstrates how assertions can be used to test that a function parameter has a valid value range: uint8_t myArray[4] = { 1, 2, 3, 4 }; void IncrementArrayElement(int8_t index) { /* Make sure the array index is positive. */ TBX_ASSERT(index >= 0); /* Make sure the array index is not out of range. */ TBX_ASSERT(index < (sizeof(myArray)/sizeof(myArray[0]))); /* Increment the array element at the requested index. */ myArray[index]++; } The next example shows how you can register your own assertion error handler, which overrides the internal error handling: #include <stdio.h> void MyAssertionHandler(const char * const file, uint32_t line) { /* Display the assertion error info. */ printf(\"[ERROR] Assertion in %s at line %lu\", file, line); } int main(void) { /* Register the application specific assertion handler. */ TbxAssertSetHandler(MyAssertionHandler); /* TODO Implement your program here. */ return 0; }","title":"Examples"},{"location":"assertions/#configuration","text":"The enable the assertion error handling, set the macro TBX_CONF_ASSERTIONS_ENABLE to a value of 1 : /** \\brief Enable/disable run-time assertions. */ #define TBX_CONF_ASSERTIONS_ENABLE (1U) To disable the assertion error handling, set this macro to a value of 0 . Note that there is not need to remove the TBX_ASSERT() macros from your code. MicroTBX automatically makes the TBX_ASSERT() macro and empty macro without side effect, when assertion error handling was disabled. Assertions are typically enabled in a debug version of the software program and disabled in a release version of the software program.","title":"Configuration"},{"location":"assertions/#extra-tips","text":"Make sure to write your assertion statements such that you do not accidentally remove functionality from your software program, after disabling the assertion error handling. So instead of the following: FATFS fs; void MountDrive(void) { /* Mount the drive and make sure the drive mounting succeeded. */ TBX_ASSERT(f_mount(&fs, \"0:\", 0) == FR_OK); } Do the following: FATFS fs; void MountDrive(void) { FRESULT fresult; /* Mount the drive. */ fresult = f_mount(&fs, \"0:\", 0); /* Make sure the drive mounting succeeded. */ TBX_ASSERT(fresult == FR_OK); } To be sure that the before mentioned problem does not occur, one could make the argument that assertion error handling should simply never be disabled.","title":"Extra tips"},{"location":"checksum/","text":"Checksums A checksum is an integer value that can verify the contents of a data block. In embedded software programs, the common purposes of a checksum are: to validate the contents of a data bock, and to detect accidental changes in a data block. A checksum could for example be calculated over the entire program code that is programmed into flash memory. The checksum could then stored at another location in flash memory, with the help of the debugger / flash programmer. At program startup, the initialization code could recalculate the checksum and compare it with the value programmed by the debugger / flash programmer. It the values do not match, you can conclude that somehow the flash contents got changed and the software program might not execute properly. Checksums are also often embedded in communication data streams. The sender calculates and adds the checksum to the communication data. Upon reception, the receiver recalculates the checksum and compares the calculated value with the value that was added by the sender. The communication data is deemed valid if both values match. Usage MicroTBX includes functionality to calculate both 16-bit and 32-bit checksum values over a fixed length byte array, using the following cyclic redundancy check (CRC) algorithms: CRC16-CCITT-FALSE CRC32-MPEG2 To calculate the 16-bit checksum value over a number of bytes, function TbxChecksumCrc16Calculate() is available. In case a 32-bit checksum value is preferred, function TbxChecksumCrc32Calculate() can be called. Examples The following example declares a data block with communication data, consisting of 32 bytes (8 * 4). Function CalculateChecksum() demonstrates how a 32-bit checksum over the communication data is calculated. The sender of this data packet could send the checksum value together with the actual packet data. The receiver could read out the received packet data and packet checksum value. Next, it calls function VerifyChecksum() to check if the packet data is valid and no bits got changed during the communication transfer. uint32_t communicationData[8] = { 0x8ef9c15f, 0x4323a3cb, 0xb12ba488, 0xb3f5ec04, 0xc1c7544f, 0x4140ec9d, 0xc5dd421a, 0x14d57e3d }; uint32_t CalculateChecksum(void) { uint8_t result; uint8_t * dataPtr; size_t dataLen; /* Collect data block settings. */ dataPtr = (uint8_t *)&communicationData[0]; dataLen = sizeof(communicationData)/sizeof(uint8_t); /* Calculate the checksum. */ result = TbxChecksumCrc32Calculate(dataPtr, dataLen); /* Return the result. */ return result; } uint8_t VerifyChecksum(uint32_t checksum) { uint8_t result = TBX_FALSE; uint32_t calculatedChecksum; /* Recalculate the checksum. */ calculatedChecksum = CalculateChecksum(); /* Verify that the data contents are still valid. */ if (calculatedChecksum == checksum) { result = TBX_TRUE; } /* Return the result. */ return result; } Configuration The 16-bit and 32-bit CRC algorithms uses a specific polynomial value and are seeded with an initial value. The default configuration of these values work fine and there is no need to change these. If for some reason your application requires you to set different values for the initial and polynomial values, you can override the default configuration by adding the following macros to the tbx_conf.h configuration file and assign the values you prefer: /** \\brief Polynomial of the 16-bit CRC. */ #define TBX_CONF_CHECKSUM_CRC16_POLYNOM (0x1021U) /** \\brief Initial value of the 6-bit CRC calculation. */ #define TBX_CONF_CHECKSUM_CRC16_INITIAL (0xFFFFU) /** \\brief Polynomial of the 32-bit CRC. */ #define TBX_CONF_CHECKSUM_CRC32_POLYNOM (0x04C11DB7UL) /** \\brief Initial value of the 32-bit CRC calculation. */ #define TBX_CONF_CHECKSUM_CRC32_INITIAL (0xFFFFFFFFUL)","title":"Checksums"},{"location":"checksum/#checksums","text":"A checksum is an integer value that can verify the contents of a data block. In embedded software programs, the common purposes of a checksum are: to validate the contents of a data bock, and to detect accidental changes in a data block. A checksum could for example be calculated over the entire program code that is programmed into flash memory. The checksum could then stored at another location in flash memory, with the help of the debugger / flash programmer. At program startup, the initialization code could recalculate the checksum and compare it with the value programmed by the debugger / flash programmer. It the values do not match, you can conclude that somehow the flash contents got changed and the software program might not execute properly. Checksums are also often embedded in communication data streams. The sender calculates and adds the checksum to the communication data. Upon reception, the receiver recalculates the checksum and compares the calculated value with the value that was added by the sender. The communication data is deemed valid if both values match.","title":"Checksums"},{"location":"checksum/#usage","text":"MicroTBX includes functionality to calculate both 16-bit and 32-bit checksum values over a fixed length byte array, using the following cyclic redundancy check (CRC) algorithms: CRC16-CCITT-FALSE CRC32-MPEG2 To calculate the 16-bit checksum value over a number of bytes, function TbxChecksumCrc16Calculate() is available. In case a 32-bit checksum value is preferred, function TbxChecksumCrc32Calculate() can be called.","title":"Usage"},{"location":"checksum/#examples","text":"The following example declares a data block with communication data, consisting of 32 bytes (8 * 4). Function CalculateChecksum() demonstrates how a 32-bit checksum over the communication data is calculated. The sender of this data packet could send the checksum value together with the actual packet data. The receiver could read out the received packet data and packet checksum value. Next, it calls function VerifyChecksum() to check if the packet data is valid and no bits got changed during the communication transfer. uint32_t communicationData[8] = { 0x8ef9c15f, 0x4323a3cb, 0xb12ba488, 0xb3f5ec04, 0xc1c7544f, 0x4140ec9d, 0xc5dd421a, 0x14d57e3d }; uint32_t CalculateChecksum(void) { uint8_t result; uint8_t * dataPtr; size_t dataLen; /* Collect data block settings. */ dataPtr = (uint8_t *)&communicationData[0]; dataLen = sizeof(communicationData)/sizeof(uint8_t); /* Calculate the checksum. */ result = TbxChecksumCrc32Calculate(dataPtr, dataLen); /* Return the result. */ return result; } uint8_t VerifyChecksum(uint32_t checksum) { uint8_t result = TBX_FALSE; uint32_t calculatedChecksum; /* Recalculate the checksum. */ calculatedChecksum = CalculateChecksum(); /* Verify that the data contents are still valid. */ if (calculatedChecksum == checksum) { result = TBX_TRUE; } /* Return the result. */ return result; }","title":"Examples"},{"location":"checksum/#configuration","text":"The 16-bit and 32-bit CRC algorithms uses a specific polynomial value and are seeded with an initial value. The default configuration of these values work fine and there is no need to change these. If for some reason your application requires you to set different values for the initial and polynomial values, you can override the default configuration by adding the following macros to the tbx_conf.h configuration file and assign the values you prefer: /** \\brief Polynomial of the 16-bit CRC. */ #define TBX_CONF_CHECKSUM_CRC16_POLYNOM (0x1021U) /** \\brief Initial value of the 6-bit CRC calculation. */ #define TBX_CONF_CHECKSUM_CRC16_INITIAL (0xFFFFU) /** \\brief Polynomial of the 32-bit CRC. */ #define TBX_CONF_CHECKSUM_CRC32_POLYNOM (0x04C11DB7UL) /** \\brief Initial value of the 32-bit CRC calculation. */ #define TBX_CONF_CHECKSUM_CRC32_INITIAL (0xFFFFFFFFUL)","title":"Configuration"},{"location":"critsect/","text":"Critical sections In an interrupt driven embedded software program, problems can occur with global resource sharing. A global resource can for example be a global data structure, a peripheral, or a communication device. Imagine a situation where the software program is writing to a global variable and before the write operation is completed, an interrupt occurred. The associated interrupt handler could write to the same global variable. After the interrupt is completed, to initial write operation completes. The global variable now holds invalid data. Such data concurrency issues are resolved by performing the global resource access in a critical section. In a critical section, no interrupt can occur and you can therefore be certain that you have mutual exclusive access to the global resource. Usage In MicroTBX a critical section is entered by calling the function TbxCriticalSectionEnter() . After this the global resource can be safely accessed. Once done, the critical section is left by calling the function TbxCriticalSectionExit() . This means that both functions must always be used pair-wise. Each call to TbxCriticalSectionEnter() must eventually be followed by a call to TbxCriticalSectionExit() . Note that MicroTBX supports nested critical sections. It is completely fine if your software program enters the critical section again, even if it is already in a critical section. Examples The following example contains a global variable myMessage and a function TransmitMessage() . Imagine that this function can be called both from the main program loop and from an interrupt. This makes variable myMessage a shared resource. A critical section is applied to obtain mutual exclusive access to the variable myMessage : struct { uint32_t id; uint8_t len; uint8_t data[8]; } myMessage; void TransmitMessage(void) { /* Obtain mutual exclusive access to myMessage. */ TbxCriticalSectionEnter(); /* Prepare and send the message. */ myMessage.id++; myMessage.len = 1u; myMessage.data[0]++; SendMessage(&myMessage); /* Release mutual exclusive access to myMessage. */ TbxCriticalSectionExit(); }","title":"Critical sections"},{"location":"critsect/#critical-sections","text":"In an interrupt driven embedded software program, problems can occur with global resource sharing. A global resource can for example be a global data structure, a peripheral, or a communication device. Imagine a situation where the software program is writing to a global variable and before the write operation is completed, an interrupt occurred. The associated interrupt handler could write to the same global variable. After the interrupt is completed, to initial write operation completes. The global variable now holds invalid data. Such data concurrency issues are resolved by performing the global resource access in a critical section. In a critical section, no interrupt can occur and you can therefore be certain that you have mutual exclusive access to the global resource.","title":"Critical sections"},{"location":"critsect/#usage","text":"In MicroTBX a critical section is entered by calling the function TbxCriticalSectionEnter() . After this the global resource can be safely accessed. Once done, the critical section is left by calling the function TbxCriticalSectionExit() . This means that both functions must always be used pair-wise. Each call to TbxCriticalSectionEnter() must eventually be followed by a call to TbxCriticalSectionExit() . Note that MicroTBX supports nested critical sections. It is completely fine if your software program enters the critical section again, even if it is already in a critical section.","title":"Usage"},{"location":"critsect/#examples","text":"The following example contains a global variable myMessage and a function TransmitMessage() . Imagine that this function can be called both from the main program loop and from an interrupt. This makes variable myMessage a shared resource. A critical section is applied to obtain mutual exclusive access to the variable myMessage : struct { uint32_t id; uint8_t len; uint8_t data[8]; } myMessage; void TransmitMessage(void) { /* Obtain mutual exclusive access to myMessage. */ TbxCriticalSectionEnter(); /* Prepare and send the message. */ myMessage.id++; myMessage.len = 1u; myMessage.data[0]++; SendMessage(&myMessage); /* Release mutual exclusive access to myMessage. */ TbxCriticalSectionExit(); }","title":"Examples"},{"location":"crypto/","text":"Cryptography The cryptography software component contains functionality to encrypt and decrypt data blocks. Encryption essentially changes the data contents such that its contents can no longer be interpreted by unwanted third parties. Only the party that has access to the so called key, with which the data was encrypted, can decrypt the data contents back into its original state. Encryption enables you to securely protect data that you don't want anyone else to have access to. Possible fields of application in an embedded software program are: securing communication data, securing parameters or other proprietary data stored in EEPROM, etc. The cryptography software component is based on 256-bit AES ECB. AES stands for Advanced Encryption Standard and ECB stands for Electronic CodeBook. The key needed to perform the actual encryption and decryption is 256-bit in size. In C code, this is an array of 32 bytes. The only restriction is that the data to encrypt or decrypt must always be a multiple of 16 bytes in size. If this is not the case, the data needs to be aligned to a multiple of 16 bytes prior to performing the encryption/decryption operation. Usage The first step is to define your 256-bit cryptography key. This is nothing more than an array of 32 bytes. You can decide on the contents yourself. The only important part to remember is that you need the same key for both the encryption and decryption steps, in order to get the original data back when decrypting the encrypted data. Here is an example of how to define a cryptography key in C: /* The 256-bit key that will be used to encrypt and decrypt data. */ const uint8_t cryptoKey[32] = { 0x32, 0x72, 0x35, 0x75, 0x38, 0x78, 0x21, 0x41, 0x25, 0x44, 0x2A, 0x47, 0x2D, 0x4B, 0x61, 0x50, 0x64, 0x53, 0x67, 0x56, 0x6B, 0x59, 0x70, 0x33, 0x73, 0x36, 0x76, 0x39, 0x79, 0x24, 0x42, 0x3F }; Note that you can use an encryption key generator to assist with getting unique contents for your cryptography key. To encrypt a 16-byte aligned data block, the function TbxCryptoAes256Encrypt() is available. To decrypt the data block back to its original state, the function TbxCryptoAes256Decrypt() can be called. Examples The following code example first encrypts the contents of a data buffer. Afterwards, the encrypted data is decrypted again. Followed by a verification to test that the decrypted data actually resembles the original data. The cryptoKey[] presented above serves as the 256-bit cryptography key: /* Original data. */ const uint8_t originalData[64] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F }; /* Temporary buffer to storing the encrypted/decrypted data. */ uint8_t buffer[64]; /* Array indexer for looping through array data. */ size_t idx; /* Copy the original data to the buffer. */ for (idx = 0U; idx < 64U; idx++) { buffer[idx] = originalData[idx]; } /* Encrypt the data in the buffer. */ TbxCryptoAes256Encrypt(buffer, 64, cryptoKey); /* Decrypt the data in the buffer. */ TbxCryptoAes256Decrypt(buffer, 64, cryptoKey); /* Verify that the decrypted data is the same as the original data. */ for (idx = 0U; idx < 64U; idx++) { if (buffer[idx] != originalData[idx]) { TBX_ASSERT(TBX_ERROR); } }","title":"Cryptography"},{"location":"crypto/#cryptography","text":"The cryptography software component contains functionality to encrypt and decrypt data blocks. Encryption essentially changes the data contents such that its contents can no longer be interpreted by unwanted third parties. Only the party that has access to the so called key, with which the data was encrypted, can decrypt the data contents back into its original state. Encryption enables you to securely protect data that you don't want anyone else to have access to. Possible fields of application in an embedded software program are: securing communication data, securing parameters or other proprietary data stored in EEPROM, etc. The cryptography software component is based on 256-bit AES ECB. AES stands for Advanced Encryption Standard and ECB stands for Electronic CodeBook. The key needed to perform the actual encryption and decryption is 256-bit in size. In C code, this is an array of 32 bytes. The only restriction is that the data to encrypt or decrypt must always be a multiple of 16 bytes in size. If this is not the case, the data needs to be aligned to a multiple of 16 bytes prior to performing the encryption/decryption operation.","title":"Cryptography"},{"location":"crypto/#usage","text":"The first step is to define your 256-bit cryptography key. This is nothing more than an array of 32 bytes. You can decide on the contents yourself. The only important part to remember is that you need the same key for both the encryption and decryption steps, in order to get the original data back when decrypting the encrypted data. Here is an example of how to define a cryptography key in C: /* The 256-bit key that will be used to encrypt and decrypt data. */ const uint8_t cryptoKey[32] = { 0x32, 0x72, 0x35, 0x75, 0x38, 0x78, 0x21, 0x41, 0x25, 0x44, 0x2A, 0x47, 0x2D, 0x4B, 0x61, 0x50, 0x64, 0x53, 0x67, 0x56, 0x6B, 0x59, 0x70, 0x33, 0x73, 0x36, 0x76, 0x39, 0x79, 0x24, 0x42, 0x3F }; Note that you can use an encryption key generator to assist with getting unique contents for your cryptography key. To encrypt a 16-byte aligned data block, the function TbxCryptoAes256Encrypt() is available. To decrypt the data block back to its original state, the function TbxCryptoAes256Decrypt() can be called.","title":"Usage"},{"location":"crypto/#examples","text":"The following code example first encrypts the contents of a data buffer. Afterwards, the encrypted data is decrypted again. Followed by a verification to test that the decrypted data actually resembles the original data. The cryptoKey[] presented above serves as the 256-bit cryptography key: /* Original data. */ const uint8_t originalData[64] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F }; /* Temporary buffer to storing the encrypted/decrypted data. */ uint8_t buffer[64]; /* Array indexer for looping through array data. */ size_t idx; /* Copy the original data to the buffer. */ for (idx = 0U; idx < 64U; idx++) { buffer[idx] = originalData[idx]; } /* Encrypt the data in the buffer. */ TbxCryptoAes256Encrypt(buffer, 64, cryptoKey); /* Decrypt the data in the buffer. */ TbxCryptoAes256Decrypt(buffer, 64, cryptoKey); /* Verify that the decrypted data is the same as the original data. */ for (idx = 0U; idx < 64U; idx++) { if (buffer[idx] != originalData[idx]) { TBX_ASSERT(TBX_ERROR); } }","title":"Examples"},{"location":"extra/","text":"Extra functionality You can find some optional and extra functionality in the directory source/extra . This section provides additional information regarding this functionality. MicroTBX for FreeRTOS The FreeRTOS real-time operating system is widely used in the embedded industry. No wonder, because it's free, open source, high quality, MISRA compliant and maintained by AWS . Whenever you use both FreeRTOS and MicroTBX, a few pieces of functionality are redundant. Both MicroTBX and FreeRTOS offer heap management and assertion functionality. There is nothing wrong with using both. However, if you'd like to reap the benefits of MicroTBX, while also using FreeRTOS, consider using the files in directory: source/extra/freertos/ Heap management FreeRTOS ships with a few different examples for heap management. Some allow just one-time memory allocation, some feature functionality to release allocated memory again, with minimal memory fragmentation. You can find these examples in directory: FreeRTOS/Source/portable/MemMang/ The file tbx_freertos.c offers an alternative heap management implementation, using MicroTBX's memory pools. This allows you to dynamically allocate and release memory on the heap, for your application's FreeRTOS objects. To use this heap management solution, you just need to remove the heap_x.c source file from your project and compile and link tbx_freertos.c instead. Assertions In the FreeRTOS configuration header file FreeRTOSConfig.h , you can add and configure the configASSERT macro to enable assertions in the FreeRTOS code base. MicroTBX includes an assertion module that you can use for this. The easiest way to link the MicroTBX assertion TBX_ASSERT macro to the FreeRTOS configASSERT macro, is by including the tbx_freertos.h header file all the way at the end. Just before the last #endif : #define INCLUDE_vTaskCleanUpResources 1 #define INCLUDE_vTaskSuspend 1 #define INCLUDE_vTaskDelayUntil 1 #define INCLUDE_vTaskDelay 1 #define INCLUDE_uxTaskGetStackHighWaterMark 1 /* Use MicroTBX assertion in FreeRTOS. */ #include \"tbx_freertos.h\" /* <---- ADD THIS LINE */ #endif /* FREERTOS_CONFIG_H */ Just make sure to add the directory, where the tbx_freertos.h resides, to your compiler's search path for included header files. Alternatively, you can directly add and configure the configASSERT macro as follows in FreeRTOSConfig.h : #include \"microtbx.h\" #define configASSERT( x ) TBX_ASSERT( x ) C++ new and delete using MicroTBX memory pools On a microcontroller it is totally fine to dynamically allocate memory on the heap using new (or malloc ). It gets potentially troublesome when you also release it at run-time using delete (or free ). Multiple allocation and release operations can cause memory fragmentation. In a worst case scenario this leads to memory allocation failures, because of running out of heap memory. A possible solution is by dynamically allocating memory using memory pools. This lowers the risk of memory fragmentation. With a carefully selected memory pool setup, you can even eliminate this risk completely. Allowing you to dynamically allocate and release memory during run-time. MicroTBX includes a ready-made memory pool module that can be used for this purpose. One way to approach this is by using C++ placement new instead of the usual new . This allows you the first allocate memory from a memory pool and then place the new object exactly at that memory, instead of having the new operator do the allocation. The only issue with this is that there is no placement delete . This means that to delete the object, you need to manually call its destructor and then give the allocated memory back to the memory pool. Definitely an option, it just requires a bit more work. Another approach is to overload the default new and delete operators to do all the memory allocation and release using memory pools automatically. The following source-file implements these operator overloads for the GNU ARM Embedded toolchain: source/extra/cplusplus/tbxcxx.cpp By compiling and linking this source file with your project, the global new and delete operators are overloaded, such that they by default always use the memory pools module of MicroTBX. This also apply to objects created using smart pointers.","title":"Extra functionality"},{"location":"extra/#extra-functionality","text":"You can find some optional and extra functionality in the directory source/extra . This section provides additional information regarding this functionality.","title":"Extra functionality"},{"location":"extra/#microtbx-for-freertos","text":"The FreeRTOS real-time operating system is widely used in the embedded industry. No wonder, because it's free, open source, high quality, MISRA compliant and maintained by AWS . Whenever you use both FreeRTOS and MicroTBX, a few pieces of functionality are redundant. Both MicroTBX and FreeRTOS offer heap management and assertion functionality. There is nothing wrong with using both. However, if you'd like to reap the benefits of MicroTBX, while also using FreeRTOS, consider using the files in directory: source/extra/freertos/","title":"MicroTBX for FreeRTOS"},{"location":"extra/#heap-management","text":"FreeRTOS ships with a few different examples for heap management. Some allow just one-time memory allocation, some feature functionality to release allocated memory again, with minimal memory fragmentation. You can find these examples in directory: FreeRTOS/Source/portable/MemMang/ The file tbx_freertos.c offers an alternative heap management implementation, using MicroTBX's memory pools. This allows you to dynamically allocate and release memory on the heap, for your application's FreeRTOS objects. To use this heap management solution, you just need to remove the heap_x.c source file from your project and compile and link tbx_freertos.c instead.","title":"Heap management"},{"location":"extra/#assertions","text":"In the FreeRTOS configuration header file FreeRTOSConfig.h , you can add and configure the configASSERT macro to enable assertions in the FreeRTOS code base. MicroTBX includes an assertion module that you can use for this. The easiest way to link the MicroTBX assertion TBX_ASSERT macro to the FreeRTOS configASSERT macro, is by including the tbx_freertos.h header file all the way at the end. Just before the last #endif : #define INCLUDE_vTaskCleanUpResources 1 #define INCLUDE_vTaskSuspend 1 #define INCLUDE_vTaskDelayUntil 1 #define INCLUDE_vTaskDelay 1 #define INCLUDE_uxTaskGetStackHighWaterMark 1 /* Use MicroTBX assertion in FreeRTOS. */ #include \"tbx_freertos.h\" /* <---- ADD THIS LINE */ #endif /* FREERTOS_CONFIG_H */ Just make sure to add the directory, where the tbx_freertos.h resides, to your compiler's search path for included header files. Alternatively, you can directly add and configure the configASSERT macro as follows in FreeRTOSConfig.h : #include \"microtbx.h\" #define configASSERT( x ) TBX_ASSERT( x )","title":"Assertions"},{"location":"extra/#c-new-and-delete-using-microtbx-memory-pools","text":"On a microcontroller it is totally fine to dynamically allocate memory on the heap using new (or malloc ). It gets potentially troublesome when you also release it at run-time using delete (or free ). Multiple allocation and release operations can cause memory fragmentation. In a worst case scenario this leads to memory allocation failures, because of running out of heap memory. A possible solution is by dynamically allocating memory using memory pools. This lowers the risk of memory fragmentation. With a carefully selected memory pool setup, you can even eliminate this risk completely. Allowing you to dynamically allocate and release memory during run-time. MicroTBX includes a ready-made memory pool module that can be used for this purpose. One way to approach this is by using C++ placement new instead of the usual new . This allows you the first allocate memory from a memory pool and then place the new object exactly at that memory, instead of having the new operator do the allocation. The only issue with this is that there is no placement delete . This means that to delete the object, you need to manually call its destructor and then give the allocated memory back to the memory pool. Definitely an option, it just requires a bit more work. Another approach is to overload the default new and delete operators to do all the memory allocation and release using memory pools automatically. The following source-file implements these operator overloads for the GNU ARM Embedded toolchain: source/extra/cplusplus/tbxcxx.cpp By compiling and linking this source file with your project, the global new and delete operators are overloaded, such that they by default always use the memory pools module of MicroTBX. This also apply to objects created using smart pointers.","title":"C++ new and delete using MicroTBX memory pools"},{"location":"heap/","text":"Heap In an embedded software program, memory can be dynamically allocated. The heap is available for this, which is a part of RAM specifically reserved for dynamically allocated memory. The C standard library offers the functions malloc() and free() for allocating and releasing memory on the heap. Both functions treat the heap as a byte pool, which means there is always a fragmentation risk present. The fragmentation eventually leads to a situation where memory can no longer be allocated, resulting in lost functionality or a crash of the software program in the worst case. This fragmentation risk is therefore unacceptable and another solution needs to be found for handling dynamic allocation. The solution is two-fold: Use static memory preallocation. This entails performing the memory allocation once during software program initialization and never releasing (free-ing) the allocated memory. This means that the lifetime of the allocated data spans the run-time of the entire software program. Use memory pools. With a memory pool, memory is allocated as fixed-size memory blocks (partitions). The benefit of dynamic memory allocation using memory pools is that the memory can be released again without the before mentioned fragmentation risk. It is perfect in situations when temporary data storage is needed, and the lifetime of the data is longer than just one function. MicroTBX offers software components for both solutions. The heap software component described in this section covers solution (1) with static memory preallocation. The memory pools software component covers solution (2). Usage The heap software component offers the function TbxHeapAllocate() for performing memory allocation on the heap. Because it is meant for static memory preallocation only, there is no function for free-ing the allocated memory. The idea is that function TbxHeapAllocate() is only called during the initialization of the software program, so before the infinite program loop is entered. It is basically its own implementation of malloc() , without free() . To find out how many bytes of memory are still available on the heap, function TbxHeapGetFree() can be called. If a software program has a need to allocate and release memory during the infinite program loop, the memory allocation should be performed with the functionality present in the memory pools software component. Examples The following example demonstrates how to call the functions of the heap software component. Memory for a FIFO buffer is preallocated during the software program initialization. /* A first-in first-out buffer of 32-bit values. */ uint32_t * fifoBuffer = NULL; uint32_t const fifoMaxSize = 32; uint8_t fifoIdx; /* Make sure there is enough space on the heap for the FIFO buffer. */ if (TbxHeapGetFree() < (fifoMaxSize * sizeof(uint32_t))) { TBX_ASSERT(TBX_FALSE); } /* Perform static preallocation of the FIFO buffer. */ fifoBuffer = TbxHeapAllocate(fifoMaxSize * sizeof(uint32_t)); /* Make sure the allocation was successful. */ TBX_ASSERT(fifoBuffer != NULL); /* Initialize the FIFO buffer. */ for (fifoIdx = 0; fifoIdx < fifoMaxSize; fifoIdx++) { fifoBuffer[fifoIdx] = 0; } Configuration The maximum size of the heap is configured with macro TBX_CONF_HEAP_SIZE : /** \\brief Configure the size of the heap in bytes. */ #define TBX_CONF_HEAP_SIZE (2048U)","title":"Heap"},{"location":"heap/#heap","text":"In an embedded software program, memory can be dynamically allocated. The heap is available for this, which is a part of RAM specifically reserved for dynamically allocated memory. The C standard library offers the functions malloc() and free() for allocating and releasing memory on the heap. Both functions treat the heap as a byte pool, which means there is always a fragmentation risk present. The fragmentation eventually leads to a situation where memory can no longer be allocated, resulting in lost functionality or a crash of the software program in the worst case. This fragmentation risk is therefore unacceptable and another solution needs to be found for handling dynamic allocation. The solution is two-fold: Use static memory preallocation. This entails performing the memory allocation once during software program initialization and never releasing (free-ing) the allocated memory. This means that the lifetime of the allocated data spans the run-time of the entire software program. Use memory pools. With a memory pool, memory is allocated as fixed-size memory blocks (partitions). The benefit of dynamic memory allocation using memory pools is that the memory can be released again without the before mentioned fragmentation risk. It is perfect in situations when temporary data storage is needed, and the lifetime of the data is longer than just one function. MicroTBX offers software components for both solutions. The heap software component described in this section covers solution (1) with static memory preallocation. The memory pools software component covers solution (2).","title":"Heap"},{"location":"heap/#usage","text":"The heap software component offers the function TbxHeapAllocate() for performing memory allocation on the heap. Because it is meant for static memory preallocation only, there is no function for free-ing the allocated memory. The idea is that function TbxHeapAllocate() is only called during the initialization of the software program, so before the infinite program loop is entered. It is basically its own implementation of malloc() , without free() . To find out how many bytes of memory are still available on the heap, function TbxHeapGetFree() can be called. If a software program has a need to allocate and release memory during the infinite program loop, the memory allocation should be performed with the functionality present in the memory pools software component.","title":"Usage"},{"location":"heap/#examples","text":"The following example demonstrates how to call the functions of the heap software component. Memory for a FIFO buffer is preallocated during the software program initialization. /* A first-in first-out buffer of 32-bit values. */ uint32_t * fifoBuffer = NULL; uint32_t const fifoMaxSize = 32; uint8_t fifoIdx; /* Make sure there is enough space on the heap for the FIFO buffer. */ if (TbxHeapGetFree() < (fifoMaxSize * sizeof(uint32_t))) { TBX_ASSERT(TBX_FALSE); } /* Perform static preallocation of the FIFO buffer. */ fifoBuffer = TbxHeapAllocate(fifoMaxSize * sizeof(uint32_t)); /* Make sure the allocation was successful. */ TBX_ASSERT(fifoBuffer != NULL); /* Initialize the FIFO buffer. */ for (fifoIdx = 0; fifoIdx < fifoMaxSize; fifoIdx++) { fifoBuffer[fifoIdx] = 0; }","title":"Examples"},{"location":"heap/#configuration","text":"The maximum size of the heap is configured with macro TBX_CONF_HEAP_SIZE : /** \\brief Configure the size of the heap in bytes. */ #define TBX_CONF_HEAP_SIZE (2048U)","title":"Configuration"},{"location":"license/","text":"License MicroTBX is released under the MIT license. This permissive license enables you to include and distribute MicroTBX with your firmware, even if it is proprietary. Refer to the following table for answers to frequently asked questions regarding the MIT license. Question MIT license Is MicroTBX free? yes Do I have the right to change the MicroTBX source code? yes Can I use MicroTBX in my closed source product? yes Do I have to open my source code? no Do I have to open source my changes to MicroTBX? no Do I have to offer the MicroTBX source code to users of my product? no Do I have to document that my product uses MicroTBX? no Can I redistribute MicroTBX in source code format? yes Can I receive professional technical support on a commercial basis? yes The actual license text is as follows: /*--------------------------------------------------------------------------------------- * C O P Y R I G H T *---------------------------------------------------------------------------------------- * Copyright (c) 2019 by Feaser www.feaser.com All rights reserved * *---------------------------------------------------------------------------------------- * L I C E N S E *---------------------------------------------------------------------------------------- * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */","title":"License"},{"location":"license/#license","text":"MicroTBX is released under the MIT license. This permissive license enables you to include and distribute MicroTBX with your firmware, even if it is proprietary. Refer to the following table for answers to frequently asked questions regarding the MIT license. Question MIT license Is MicroTBX free? yes Do I have the right to change the MicroTBX source code? yes Can I use MicroTBX in my closed source product? yes Do I have to open my source code? no Do I have to open source my changes to MicroTBX? no Do I have to offer the MicroTBX source code to users of my product? no Do I have to document that my product uses MicroTBX? no Can I redistribute MicroTBX in source code format? yes Can I receive professional technical support on a commercial basis? yes The actual license text is as follows: /*--------------------------------------------------------------------------------------- * C O P Y R I G H T *---------------------------------------------------------------------------------------- * Copyright (c) 2019 by Feaser www.feaser.com All rights reserved * *---------------------------------------------------------------------------------------- * L I C E N S E *---------------------------------------------------------------------------------------- * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */","title":"License"},{"location":"lists/","text":"Linked lists This software component consists of an easy-to-use set of functions for managing and sorting items in a linked list. It builds upon the memory pool functionality, which makes is possible to dynamically create, delete and automatically grow linked lists in a convenient way. Think of a linked list as an array on steroids. You do not yet have to know its size upon creation and you can insert, remove and sort its items with ease. A linked list is a sequence of data items, where each data item contains a connection to the adjacent items. In this software component the definition of a data item is a pointer to the data. The only thing you as the programmer need to take care of, is that the data pointer actually points to valid data before inserting it into the linked list. Linked lists are commonly used data structures in software programs and they are perfect for scenarios where you need to store a sequence of data, but you do not yet know the maximum number of items to store ahead of time. An example would be a first-in-first-out (FIFO) buffer. Usage Linked list can be created and deleted at any time in the software program with functions TbxListCreate() and TbxListDelete() . The TbxListCreate() function returns a pointer to the new list. This list pointer serves as a handle to the list. You can pass this handle as a parameter to all the other functions in the software component to identify the list that should be operated on. Once the list is created, you can start adding items to the list with functions TbxListInsertItemFront() , TbxListInsertItemBack() , TbxListInsertItemBefore() , and TbxListInsertItemAfter() . The function to call depends on where in the list you would like to add the item. For reading items and for iterating over items, the functions TbxListGetFirstItem() , TbxListGetLastItem() , TbxListGetPreviousItem() , and TbxListGetNextItem() are available. At any given time, you can obtain the number of items that are stored in the list with function TbxListGetSize() . Call function TbxListRemoveItem() to remove a single item from the list, or call TbxListClear() to remove all items at once. For editing the order of the items in the list, functions TbxListSwapItems() and TbxListSortItems() are available. When calling TbxListSortItems() you can specify your own function that will be called during the sort operation. In this callback function you can implement your own application specific logic for comparing two data items, therefore giving you full control and flexibility over how the sorting works. Examples This section contains a few examples to demonstrate how the linked list software component works. To keep the examples simple, some error checking of function return values was omitted. The examples assume that the following type for an arbitrary message is defined: typedef struct { uint32_t id; uint8_t len; uint8_t data[8]; } tMsg; Example 1 - FIFO buffer The first example demonstrates how quickly a first-in-first-out (FIFO) buffer can be created. Keep in mind that a linked list holds pointers to data items. It is up to the developer to allocate and release the memory for the data item. Luckily, this is easy with the help of a memory pool . tTbxList * msgBuffer; void MsgBufferInit(void) { /* Create the linked list. */ msgBuffer = TbxListCreate(); } void MsgBufferAdd(tMsg const * msg) { tMsg * newMsg; /* Allocate block from an automatically created and expanded memory pool. */ newMsg = TbxMemPoolAllocateAuto(sizeof(tMsg)); /* Copy the message to the newly allocated memory. */ *newMsg = *msg; /* Add the message at the end of the list. */ TbxListInsertItemBack(msgBuffer, newMsg); } uint8_t MsgBufferGet(tMsg * msg) { uint8_t result = TBX_ERROR; tMsg * oldMsg; uint8_t idx; /* Get the oldest message from the list, if any. */ oldMsg = TbxListGetFirstItem(msgBuffer); if (oldMsg != NULL) { /* Delete it from the list now that we read it. */ TbxListRemoveItem(msgBuffer, oldMsg); /* Copy the message contents. */ *msg = *oldMsg; /* Give the allocated memory for the message back to the pool. */ TbxMemPoolRelease(oldMsg); /* Update the result. */ result = TBX_OK; } return result; } You now not only have a FIFO buffer for storing messages, but its implementation is such that it can automatically grow in size. Memory pools form the foundation for this, meaning that you do not have to worry about memory fragmentation. The following code demonstrates how messages can be stored and retrieved from this FIFO buffer: /* Initialize the message FIFO buffer. */ MsgBufferInit(); /* Add a few messages. */ tMsg newMsg1 = { 0x200, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; tMsg newMsg2 = { 0x300, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; tMsg newMsg3 = { 0x100, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; MsgBufferAdd(&newMsg1); MsgBufferAdd(&newMsg2); MsgBufferAdd(&newMsg3); /* Extract messages from the FIFO buffer. */ tMsg msg; while (MsgBufferGet(&msg) == TBX_OK) { printf(\" Item ID: 0x%x\\n\", msg.id); } After running this code, the following is shown: Item ID: 0x200 Item ID: 0x300 Item ID: 0x100 Example 2 - Iterate list The second example demonstrates how to iterate through contents of a linked list. The following function prints information about the list contents: void MsgBufferPrint(void) { tMsg * msg; size_t cnt = 0; printf(\"Number of items: %d\\n\", TbxListGetSize(msgBuffer)); msg = TbxListGetFirstItem(msgBuffer); while (msg != NULL) { printf(\" Item %d ID: 0x%x\\n\", ++cnt, msg->id); msg = TbxListGetNextItem(msgBuffer, msg); } } After running this example code: /* Initialize the message FIFO buffer. */ MsgBufferInit(); /* Add a few messages. */ tMsg newMsg1 = { 0x200, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; tMsg newMsg2 = { 0x300, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; tMsg newMsg3 = { 0x100, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; MsgBufferAdd(&newMsg1); MsgBufferAdd(&newMsg2); MsgBufferAdd(&newMsg3); /* Print current FIFO buffer contents. */ MsgBufferPrint(); The following is shown: Number of items: 3 Item 1 ID: 0x200 Item 2 ID: 0x300 Item 3 ID: 0x100 Example 3 - Sort list The third example builds upon example 2, where there are three messages in the list. Let's assume you want to sort the list contents based on the message identifier. For this you could implement the following function for comparing two messages: uint8_t CompareMessage(void const * item1, void const * item2) { uint8_t result = TBX_FALSE; tMsg const * msg1 = item1; tMsg const * msg2 = item2; if (msg1->id > msg2->id) { result = TBX_TRUE; } return result; } To perform the actual sort operation, you could run this code: /* Print FIFO buffer contents before sorting. */ printf(\"--- Before sorting ---\\n\"); MsgBufferPrint(); /* Sort the buffer based on the message identifier. */ TbxListSortItems(msgBuffer, CompareMessage); /* Print FIFO buffer contents after sorting. */ printf(\"--- After sorting ---\\n\"); MsgBufferPrint(); The following is shown: --- Before sorting --- Number of items: 3 Item 1 ID: 0x200 Item 2 ID: 0x300 Item 3 ID: 0x100 --- After sorting --- Number of items: 3 Item 1 ID: 0x100 Item 2 ID: 0x200 Item 3 ID: 0x300 Note that the items in the list are now sorted based on the message identifier in ascending order. Limitations This convenient and easy-to-use set of functions, for managing and sorting items in a linked list, does come with one limitation: Not all API functions can be used, if you plan on storing items in the list that could potentially point to the same memory address. In case you plan on potentially storing such duplicate entries in the list, the following API functions should NOT be used: TbxListInsertItemBefore() TbxListInsertItemAfter() TbxListGetPreviousItem() TbxListGetNextItem() TbxListRemoveItem() TbxListSwapItems() Configuration The linked list software component itself does not have to be configured. However, when creating a linked list and inserting items into it, the memory needed is dynamically allocated with the help of a memory pool. Because a memory pool takes memory from the heap, make sure the heap size is configured large enough with the help of macro TBX_CONF_HEAP_SIZE : /** \\brief Configure the size of the heap in bytes. */ #define TBX_CONF_HEAP_SIZE (2048U)","title":"Linked lists"},{"location":"lists/#linked-lists","text":"This software component consists of an easy-to-use set of functions for managing and sorting items in a linked list. It builds upon the memory pool functionality, which makes is possible to dynamically create, delete and automatically grow linked lists in a convenient way. Think of a linked list as an array on steroids. You do not yet have to know its size upon creation and you can insert, remove and sort its items with ease. A linked list is a sequence of data items, where each data item contains a connection to the adjacent items. In this software component the definition of a data item is a pointer to the data. The only thing you as the programmer need to take care of, is that the data pointer actually points to valid data before inserting it into the linked list. Linked lists are commonly used data structures in software programs and they are perfect for scenarios where you need to store a sequence of data, but you do not yet know the maximum number of items to store ahead of time. An example would be a first-in-first-out (FIFO) buffer.","title":"Linked lists"},{"location":"lists/#usage","text":"Linked list can be created and deleted at any time in the software program with functions TbxListCreate() and TbxListDelete() . The TbxListCreate() function returns a pointer to the new list. This list pointer serves as a handle to the list. You can pass this handle as a parameter to all the other functions in the software component to identify the list that should be operated on. Once the list is created, you can start adding items to the list with functions TbxListInsertItemFront() , TbxListInsertItemBack() , TbxListInsertItemBefore() , and TbxListInsertItemAfter() . The function to call depends on where in the list you would like to add the item. For reading items and for iterating over items, the functions TbxListGetFirstItem() , TbxListGetLastItem() , TbxListGetPreviousItem() , and TbxListGetNextItem() are available. At any given time, you can obtain the number of items that are stored in the list with function TbxListGetSize() . Call function TbxListRemoveItem() to remove a single item from the list, or call TbxListClear() to remove all items at once. For editing the order of the items in the list, functions TbxListSwapItems() and TbxListSortItems() are available. When calling TbxListSortItems() you can specify your own function that will be called during the sort operation. In this callback function you can implement your own application specific logic for comparing two data items, therefore giving you full control and flexibility over how the sorting works.","title":"Usage"},{"location":"lists/#examples","text":"This section contains a few examples to demonstrate how the linked list software component works. To keep the examples simple, some error checking of function return values was omitted. The examples assume that the following type for an arbitrary message is defined: typedef struct { uint32_t id; uint8_t len; uint8_t data[8]; } tMsg;","title":"Examples"},{"location":"lists/#example-1-fifo-buffer","text":"The first example demonstrates how quickly a first-in-first-out (FIFO) buffer can be created. Keep in mind that a linked list holds pointers to data items. It is up to the developer to allocate and release the memory for the data item. Luckily, this is easy with the help of a memory pool . tTbxList * msgBuffer; void MsgBufferInit(void) { /* Create the linked list. */ msgBuffer = TbxListCreate(); } void MsgBufferAdd(tMsg const * msg) { tMsg * newMsg; /* Allocate block from an automatically created and expanded memory pool. */ newMsg = TbxMemPoolAllocateAuto(sizeof(tMsg)); /* Copy the message to the newly allocated memory. */ *newMsg = *msg; /* Add the message at the end of the list. */ TbxListInsertItemBack(msgBuffer, newMsg); } uint8_t MsgBufferGet(tMsg * msg) { uint8_t result = TBX_ERROR; tMsg * oldMsg; uint8_t idx; /* Get the oldest message from the list, if any. */ oldMsg = TbxListGetFirstItem(msgBuffer); if (oldMsg != NULL) { /* Delete it from the list now that we read it. */ TbxListRemoveItem(msgBuffer, oldMsg); /* Copy the message contents. */ *msg = *oldMsg; /* Give the allocated memory for the message back to the pool. */ TbxMemPoolRelease(oldMsg); /* Update the result. */ result = TBX_OK; } return result; } You now not only have a FIFO buffer for storing messages, but its implementation is such that it can automatically grow in size. Memory pools form the foundation for this, meaning that you do not have to worry about memory fragmentation. The following code demonstrates how messages can be stored and retrieved from this FIFO buffer: /* Initialize the message FIFO buffer. */ MsgBufferInit(); /* Add a few messages. */ tMsg newMsg1 = { 0x200, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; tMsg newMsg2 = { 0x300, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; tMsg newMsg3 = { 0x100, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; MsgBufferAdd(&newMsg1); MsgBufferAdd(&newMsg2); MsgBufferAdd(&newMsg3); /* Extract messages from the FIFO buffer. */ tMsg msg; while (MsgBufferGet(&msg) == TBX_OK) { printf(\" Item ID: 0x%x\\n\", msg.id); } After running this code, the following is shown: Item ID: 0x200 Item ID: 0x300 Item ID: 0x100","title":"Example 1 - FIFO buffer"},{"location":"lists/#example-2-iterate-list","text":"The second example demonstrates how to iterate through contents of a linked list. The following function prints information about the list contents: void MsgBufferPrint(void) { tMsg * msg; size_t cnt = 0; printf(\"Number of items: %d\\n\", TbxListGetSize(msgBuffer)); msg = TbxListGetFirstItem(msgBuffer); while (msg != NULL) { printf(\" Item %d ID: 0x%x\\n\", ++cnt, msg->id); msg = TbxListGetNextItem(msgBuffer, msg); } } After running this example code: /* Initialize the message FIFO buffer. */ MsgBufferInit(); /* Add a few messages. */ tMsg newMsg1 = { 0x200, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; tMsg newMsg2 = { 0x300, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; tMsg newMsg3 = { 0x100, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; MsgBufferAdd(&newMsg1); MsgBufferAdd(&newMsg2); MsgBufferAdd(&newMsg3); /* Print current FIFO buffer contents. */ MsgBufferPrint(); The following is shown: Number of items: 3 Item 1 ID: 0x200 Item 2 ID: 0x300 Item 3 ID: 0x100","title":"Example 2 - Iterate list"},{"location":"lists/#example-3-sort-list","text":"The third example builds upon example 2, where there are three messages in the list. Let's assume you want to sort the list contents based on the message identifier. For this you could implement the following function for comparing two messages: uint8_t CompareMessage(void const * item1, void const * item2) { uint8_t result = TBX_FALSE; tMsg const * msg1 = item1; tMsg const * msg2 = item2; if (msg1->id > msg2->id) { result = TBX_TRUE; } return result; } To perform the actual sort operation, you could run this code: /* Print FIFO buffer contents before sorting. */ printf(\"--- Before sorting ---\\n\"); MsgBufferPrint(); /* Sort the buffer based on the message identifier. */ TbxListSortItems(msgBuffer, CompareMessage); /* Print FIFO buffer contents after sorting. */ printf(\"--- After sorting ---\\n\"); MsgBufferPrint(); The following is shown: --- Before sorting --- Number of items: 3 Item 1 ID: 0x200 Item 2 ID: 0x300 Item 3 ID: 0x100 --- After sorting --- Number of items: 3 Item 1 ID: 0x100 Item 2 ID: 0x200 Item 3 ID: 0x300 Note that the items in the list are now sorted based on the message identifier in ascending order.","title":"Example 3 - Sort list"},{"location":"lists/#limitations","text":"This convenient and easy-to-use set of functions, for managing and sorting items in a linked list, does come with one limitation: Not all API functions can be used, if you plan on storing items in the list that could potentially point to the same memory address. In case you plan on potentially storing such duplicate entries in the list, the following API functions should NOT be used: TbxListInsertItemBefore() TbxListInsertItemAfter() TbxListGetPreviousItem() TbxListGetNextItem() TbxListRemoveItem() TbxListSwapItems()","title":"Limitations"},{"location":"lists/#configuration","text":"The linked list software component itself does not have to be configured. However, when creating a linked list and inserting items into it, the memory needed is dynamically allocated with the help of a memory pool. Because a memory pool takes memory from the heap, make sure the heap size is configured large enough with the help of macro TBX_CONF_HEAP_SIZE : /** \\brief Configure the size of the heap in bytes. */ #define TBX_CONF_HEAP_SIZE (2048U)","title":"Configuration"},{"location":"mempools/","text":"Memory pools Dynamic memory allocation with the help of a memory pool is required for data that has a lifetime longer than just one function, yet shorter than the run-time of the entire software program. This is typically the case in event driven software. Take for example an embedded software program that communicates via CAN. When a CAN message reception interrupt triggers, the contents of the newly received CAN message are typically stored somewhere for later processing at task level. In this case data storage for the CAN message can be dynamically allocated and freed when it is no longer needed. The C standard library functions malloc() and free() can unfortunately not be used for this in a RAM constrained microcontroller based system. Both functions treat the heap as a byte pool, which means there is always a fragmentation risk present. This risk is unacceptable for an embedded software program. Note that if dynamic memory allocation is needed, where the lifetime of the allocated data equals the run-time of the entire software program, it is better to use the method of static memory preallocation with the help of the heap software component. The heap software component is also a part of MicroTBX. Each memory pool consists of a run-time configurable amount of fixed-sized data blocks. The software program has full control over how many memory pools it creates and how many bytes the data blocks. Usage A prerequisite to performing dynamic memory allocation, is that the software program first creates one or more memory pools. Function TbxMemPoolCreate() creates a memory pool. Through the function parameters you can specify the number of bytes for each data block inside the pool and how many data blocks it should hold. It is recommended to create the memory pools during the software program initialization, before the infinite program loop is entered. However, it is safe to create memory pools at any point in the software program. Note that if you attempt to create a memory pool with a data block size that already exists, the memory pools software component is smart enough to extend the already existing memory pool, instead of creating a new one. The trick is to tune the memory pools to your specific software program needs. When unsure about the what memory pools to create, it is a good starting point to create memory pools with sizes that are powers of two. For example, 8, 16, 32, 64, 128, etc. Once the memory pools are created, memory allocation with the memory pool software component is actually quite similar to calling the C standard library functions. To allocate memory, call TbxMemPoolAllocate() instead of malloc() . The best fitting memory pool for the data size requested, is automatically selected. Once the allocated data is no longer needed, call TbxMemPoolRelease() , instead of free() . As an alternative to TbxMemPoolAllocate() , you could use TbxMemPoolAllocateAuto() . This convenient function automatically creates a memory pool with the block size of the size you attempt to allocate, if not yet created. Additionally, it automatically expands the memory pool with one more block, in case no more free blocks are available. Examples The following example program demonstrates how memory pools are created and proves that data from the memory pools can be dynamically allocated and released over and over again. It is also an example of how you can expand an existing memory pool at a later point in time. void main(void) { size_t idx; uint8_t * dataPtr[16]; uint8_t firstLoop = TBX_TRUE; /* Create 2 memory pools with block sizes 16 and 32 that have 8 * data blocks per pool. */ TbxMemPoolCreate(8U, 16U); TbxMemPoolCreate(8U, 32U); /* Not actually used in this example. */ /* Enter the infinite program loop. */ for (;;) { /* Allocate all blocks in the memory pool with size 16. A smaller * block size (12 in this case) is automatically matched to the * memory pool with the next size up (16 in this case). */ for (idx = 0U; idx < 8U; idx++) { dataPtr[idx] = TbxMemPoolAllocate(12U); TBX_ASSERT(dataPtr[idx] != NULL); } /* Note that when the memory pool with block sizes of 16 bytes is * exhausted, the memory pool module does NOT automatically switch * to a memory pool with larger sized blocks. This was done on * purpose by design. * * The reason for this is that it is now possible to expand an * existing memory pool when it is full. Assume a situation where * all blocks in the memory pool are already allocated. The next * call to TbxMemPoolAllocate() therefore fails. You could now * call TbxMemPoolCreate() again for the same block size and the * original memory pool is expanded automatically. * * This is actually a very powerful feature, as it enables you * to dynamically enlarge the memory pool whenever needed, * provided the heap is configured to be large enough. A * simplified demonstration of this follows here. */ if (firstLoop == TBX_TRUE) { /* Reset the flag because this part should only execute during * the first loop iteration. */ firstLoop = TBX_FALSE; /* During the first loop iteration, the next allocation should * fail because all 8 blocks in the memory pool with size 16 * are already allocated. */ TBX_ASSERT(TbxMemPoolAllocate(16U) == NULL); /* Now expand the memory pool with block size 16 to add * another 8 blocks. */ TbxMemPoolCreate(8U, 16U); } /* The memory pool with block size of 16 should now have 16 * blocks. 8 were allocated, so it should be possible to * allocate another 8. */ for (idx = 8U; idx < 16U; idx++) { dataPtr[idx] = TbxMemPoolAllocate(12U); TBX_ASSERT(dataPtr[idx] != NULL); } /* The memory pool with block size of 16 should now be * exhausted and it should therefore not be possible * to allocate another block it in. Let's test this. */ TBX_ASSERT(TbxMemPoolAllocate(16U) == NULL); /* Now release all the allocated data blocks again. */ for (idx = 0U; idx < 16U; idx++) { TbxMemPoolRelease(dataPtr[idx]); } } } The following example does the same thing, however this time using the more convenient TbxMemPoolAllocateAuto() . It continuously allocates 16 blocks that are each 12 bytes in size, during each superloop iteration: void main(void) { size_t idx; uint8_t * dataPtr[16]; /* Enter the infinite program loop. */ for (;;) { /* Allocate 16 blocks with a size of 12 bytes. Note that this auto- * matically creates the memory pool and expands it with new blocks * as needed. */ for (idx = 0U; idx < 16U; idx++) { dataPtr[idx] = TbxMemPoolAllocateAuto(12U); TBX_ASSERT(dataPtr[idx] != NULL); } /* Now release all the allocated data blocks again. Note that during * the next superloop iteration, the automatically created memory * pool already holds 16 blocks of 12 bytes, which will be reused. */ for (idx = 0U; idx < 16U; idx++) { TbxMemPoolRelease(dataPtr[idx]); } } } Configuration The memory pool software component itself does not have to be configured. However, when creating memory pools with function TbxMemPoolCreate() , the data blocks are statically preallocated on the heap with the help of the heap module. In case the memory pool creation fails, it is likely that the heap size needs to be increased using the macro TBX_CONF_HEAP_SIZE : /** \\brief Configure the size of the heap in bytes. */ #define TBX_CONF_HEAP_SIZE (2048U)","title":"Memory pools"},{"location":"mempools/#memory-pools","text":"Dynamic memory allocation with the help of a memory pool is required for data that has a lifetime longer than just one function, yet shorter than the run-time of the entire software program. This is typically the case in event driven software. Take for example an embedded software program that communicates via CAN. When a CAN message reception interrupt triggers, the contents of the newly received CAN message are typically stored somewhere for later processing at task level. In this case data storage for the CAN message can be dynamically allocated and freed when it is no longer needed. The C standard library functions malloc() and free() can unfortunately not be used for this in a RAM constrained microcontroller based system. Both functions treat the heap as a byte pool, which means there is always a fragmentation risk present. This risk is unacceptable for an embedded software program. Note that if dynamic memory allocation is needed, where the lifetime of the allocated data equals the run-time of the entire software program, it is better to use the method of static memory preallocation with the help of the heap software component. The heap software component is also a part of MicroTBX. Each memory pool consists of a run-time configurable amount of fixed-sized data blocks. The software program has full control over how many memory pools it creates and how many bytes the data blocks.","title":"Memory pools"},{"location":"mempools/#usage","text":"A prerequisite to performing dynamic memory allocation, is that the software program first creates one or more memory pools. Function TbxMemPoolCreate() creates a memory pool. Through the function parameters you can specify the number of bytes for each data block inside the pool and how many data blocks it should hold. It is recommended to create the memory pools during the software program initialization, before the infinite program loop is entered. However, it is safe to create memory pools at any point in the software program. Note that if you attempt to create a memory pool with a data block size that already exists, the memory pools software component is smart enough to extend the already existing memory pool, instead of creating a new one. The trick is to tune the memory pools to your specific software program needs. When unsure about the what memory pools to create, it is a good starting point to create memory pools with sizes that are powers of two. For example, 8, 16, 32, 64, 128, etc. Once the memory pools are created, memory allocation with the memory pool software component is actually quite similar to calling the C standard library functions. To allocate memory, call TbxMemPoolAllocate() instead of malloc() . The best fitting memory pool for the data size requested, is automatically selected. Once the allocated data is no longer needed, call TbxMemPoolRelease() , instead of free() . As an alternative to TbxMemPoolAllocate() , you could use TbxMemPoolAllocateAuto() . This convenient function automatically creates a memory pool with the block size of the size you attempt to allocate, if not yet created. Additionally, it automatically expands the memory pool with one more block, in case no more free blocks are available.","title":"Usage"},{"location":"mempools/#examples","text":"The following example program demonstrates how memory pools are created and proves that data from the memory pools can be dynamically allocated and released over and over again. It is also an example of how you can expand an existing memory pool at a later point in time. void main(void) { size_t idx; uint8_t * dataPtr[16]; uint8_t firstLoop = TBX_TRUE; /* Create 2 memory pools with block sizes 16 and 32 that have 8 * data blocks per pool. */ TbxMemPoolCreate(8U, 16U); TbxMemPoolCreate(8U, 32U); /* Not actually used in this example. */ /* Enter the infinite program loop. */ for (;;) { /* Allocate all blocks in the memory pool with size 16. A smaller * block size (12 in this case) is automatically matched to the * memory pool with the next size up (16 in this case). */ for (idx = 0U; idx < 8U; idx++) { dataPtr[idx] = TbxMemPoolAllocate(12U); TBX_ASSERT(dataPtr[idx] != NULL); } /* Note that when the memory pool with block sizes of 16 bytes is * exhausted, the memory pool module does NOT automatically switch * to a memory pool with larger sized blocks. This was done on * purpose by design. * * The reason for this is that it is now possible to expand an * existing memory pool when it is full. Assume a situation where * all blocks in the memory pool are already allocated. The next * call to TbxMemPoolAllocate() therefore fails. You could now * call TbxMemPoolCreate() again for the same block size and the * original memory pool is expanded automatically. * * This is actually a very powerful feature, as it enables you * to dynamically enlarge the memory pool whenever needed, * provided the heap is configured to be large enough. A * simplified demonstration of this follows here. */ if (firstLoop == TBX_TRUE) { /* Reset the flag because this part should only execute during * the first loop iteration. */ firstLoop = TBX_FALSE; /* During the first loop iteration, the next allocation should * fail because all 8 blocks in the memory pool with size 16 * are already allocated. */ TBX_ASSERT(TbxMemPoolAllocate(16U) == NULL); /* Now expand the memory pool with block size 16 to add * another 8 blocks. */ TbxMemPoolCreate(8U, 16U); } /* The memory pool with block size of 16 should now have 16 * blocks. 8 were allocated, so it should be possible to * allocate another 8. */ for (idx = 8U; idx < 16U; idx++) { dataPtr[idx] = TbxMemPoolAllocate(12U); TBX_ASSERT(dataPtr[idx] != NULL); } /* The memory pool with block size of 16 should now be * exhausted and it should therefore not be possible * to allocate another block it in. Let's test this. */ TBX_ASSERT(TbxMemPoolAllocate(16U) == NULL); /* Now release all the allocated data blocks again. */ for (idx = 0U; idx < 16U; idx++) { TbxMemPoolRelease(dataPtr[idx]); } } } The following example does the same thing, however this time using the more convenient TbxMemPoolAllocateAuto() . It continuously allocates 16 blocks that are each 12 bytes in size, during each superloop iteration: void main(void) { size_t idx; uint8_t * dataPtr[16]; /* Enter the infinite program loop. */ for (;;) { /* Allocate 16 blocks with a size of 12 bytes. Note that this auto- * matically creates the memory pool and expands it with new blocks * as needed. */ for (idx = 0U; idx < 16U; idx++) { dataPtr[idx] = TbxMemPoolAllocateAuto(12U); TBX_ASSERT(dataPtr[idx] != NULL); } /* Now release all the allocated data blocks again. Note that during * the next superloop iteration, the automatically created memory * pool already holds 16 blocks of 12 bytes, which will be reused. */ for (idx = 0U; idx < 16U; idx++) { TbxMemPoolRelease(dataPtr[idx]); } } }","title":"Examples"},{"location":"mempools/#configuration","text":"The memory pool software component itself does not have to be configured. However, when creating memory pools with function TbxMemPoolCreate() , the data blocks are statically preallocated on the heap with the help of the heap module. In case the memory pool creation fails, it is likely that the heap size needs to be increased using the macro TBX_CONF_HEAP_SIZE : /** \\brief Configure the size of the heap in bytes. */ #define TBX_CONF_HEAP_SIZE (2048U)","title":"Configuration"},{"location":"misra/","text":"MISRA compliance Static code analysis was performed to verify compliance with MISRA-C 2012. This document lists the compliance exceptions: Global Directive Type Rationale 2.5 advisory Especially in reusable modules or peripheral drivers, macro definitions can remain unused in the module or driver itself, but should be kept for the end-user. For example version macros and configuration options. 11.5 advisory Conversions from pointer to void to pointer to other type. This is needed after allocating memory from the heap and then initializing a pointer to point to this allocated memory. Used for example when allocating memory to build a linked list. Incidental The exceptions listed in this section only apply to specific incidents in the code. External linkage for API functions A standalone library module such as this one contains API functions. They are meant to be called by the application that integrates and uses the module. As such, it can happen that an API function is not referenced outside the source-file (translation unit) that holds the function implementation. Yet, it should keep its external linkage, otherwise it won't serve its purpose as an API function anymore. For this reason, an exception was added regarding MISRA rule: Directive Type Rationale 8.7 advisory API functions should keep external linkage, even if they are not referenced outside their translation unit. Suppression of the messages related to this MISRA directive exception are marked with: /* cppcheck-suppress [misra-c2012-8.7,unmatchedSuppression] * MISRA exception: External linkage for API functions. */","title":"MISRA compliance"},{"location":"misra/#misra-compliance","text":"Static code analysis was performed to verify compliance with MISRA-C 2012. This document lists the compliance exceptions:","title":"MISRA compliance"},{"location":"misra/#global","text":"Directive Type Rationale 2.5 advisory Especially in reusable modules or peripheral drivers, macro definitions can remain unused in the module or driver itself, but should be kept for the end-user. For example version macros and configuration options. 11.5 advisory Conversions from pointer to void to pointer to other type. This is needed after allocating memory from the heap and then initializing a pointer to point to this allocated memory. Used for example when allocating memory to build a linked list.","title":"Global"},{"location":"misra/#incidental","text":"The exceptions listed in this section only apply to specific incidents in the code.","title":"Incidental"},{"location":"misra/#external-linkage-for-api-functions","text":"A standalone library module such as this one contains API functions. They are meant to be called by the application that integrates and uses the module. As such, it can happen that an API function is not referenced outside the source-file (translation unit) that holds the function implementation. Yet, it should keep its external linkage, otherwise it won't serve its purpose as an API function anymore. For this reason, an exception was added regarding MISRA rule: Directive Type Rationale 8.7 advisory API functions should keep external linkage, even if they are not referenced outside their translation unit. Suppression of the messages related to this MISRA directive exception are marked with: /* cppcheck-suppress [misra-c2012-8.7,unmatchedSuppression] * MISRA exception: External linkage for API functions. */","title":"External linkage for API functions"},{"location":"platform/","text":"Platform The platform software component contains functionality to determine platform and architecture specifics at run-time. This functionality eases cross-platform embedded software development. Usage The platform component currently contains a function to determine if the microcontroller's memory storage organization is little endian (Intel) or big endian (Motorola). To make this determination at run-time, call function TbxPlatformLittleEndian() . If it returns TBX_TRUE the code runs on a platform with little endian memory storage organization. If it returns TBX_FALSE , it is big endian. Examples Especially communication protocols typically require you to either report the endianness of the target or store data larger than one byte in a specific way. One example is on TCP/IP networks, which requires multi-byte numbers to be communicated in the big endian format. Most TCP/IP stacks offer a function named htonl() for this; An abbreviation for host-to-network-long . With the help of TbxPlatformLittleEndian() , you can implement a similar function: uint32_t StoreU32BigEndian(uint32_t value) { uint32_t result = value; /* Little endian (Intel)? */ if (TbxPlatformLittleEndian() == TBX_TRUE) { /* Get byte pointer to value and result variables. */ uint8_t * leValuePtr = (uint8_t *)&value; uint8_t * beResultPtr = (uint8_t *)&result; /* Reverse byte ordering to store value in big endian (Motorola) format. */ beResultPtr[0] = leValuePtr[3]; beResultPtr[1] = leValuePtr[2]; beResultPtr[2] = leValuePtr[1]; beResultPtr[3] = leValuePtr[0]; } /* Give the result back to the caller. */ return result; }","title":"Platform"},{"location":"platform/#platform","text":"The platform software component contains functionality to determine platform and architecture specifics at run-time. This functionality eases cross-platform embedded software development.","title":"Platform"},{"location":"platform/#usage","text":"The platform component currently contains a function to determine if the microcontroller's memory storage organization is little endian (Intel) or big endian (Motorola). To make this determination at run-time, call function TbxPlatformLittleEndian() . If it returns TBX_TRUE the code runs on a platform with little endian memory storage organization. If it returns TBX_FALSE , it is big endian.","title":"Usage"},{"location":"platform/#examples","text":"Especially communication protocols typically require you to either report the endianness of the target or store data larger than one byte in a specific way. One example is on TCP/IP networks, which requires multi-byte numbers to be communicated in the big endian format. Most TCP/IP stacks offer a function named htonl() for this; An abbreviation for host-to-network-long . With the help of TbxPlatformLittleEndian() , you can implement a similar function: uint32_t StoreU32BigEndian(uint32_t value) { uint32_t result = value; /* Little endian (Intel)? */ if (TbxPlatformLittleEndian() == TBX_TRUE) { /* Get byte pointer to value and result variables. */ uint8_t * leValuePtr = (uint8_t *)&value; uint8_t * beResultPtr = (uint8_t *)&result; /* Reverse byte ordering to store value in big endian (Motorola) format. */ beResultPtr[0] = leValuePtr[3]; beResultPtr[1] = leValuePtr[2]; beResultPtr[2] = leValuePtr[1]; beResultPtr[3] = leValuePtr[0]; } /* Give the result back to the caller. */ return result; }","title":"Examples"},{"location":"random/","text":"Random numbers The random number generator software component offers functionality for generating 32-bit random numbers. The generator algorithm is based on the linear feedback shift register approach ( LFSR ), specifically the one presented in application note 4400 from Maxim Integrated. Usage Whenever a random number is to be obtained, call function TbxRandomNumberGet() . The internal generator algorithm needs to be properly seeded. By default, the same constant value is assigned to the seed. This means that each time function TbxRandomNumberGet() is called, you get a different number, but the consecutive numbers will always be the same each time your program is restarted: Reset #1 Reset #2 Reset #3 3196210335 3196210335 3196210335 2375684060 2375684060 2375684060 3691277220 3691277220 3691277220 3596136368 3596136368 3596136368 For some applications, this behavior is acceptable. However, most applications require different random numbers to be generated each time the software program is started. This is achieved by calling TbxRandomSetSeedInitHandler() to register your own seed initialization function. The ideal implementation of your seed initialization function is such that it returns a different seed value, each time the software program is newly started. Here are some possible approaches to realize such a changing seed value: Keep one of the analog inputs on your microcontroller unconnected. Such a floating analog input picks up noise from the surrounding environment and readings will therefore always vary slightly. Configure your ADC peripheral to perform an analog to digital conversion of this analog input and use its result value to seed the generator. If your microcontroller has EEPROM or a non-volatile register, you can use it to store a value that you use to seed the generator. Then simply increment its value by one upon software program startup. This way you have a different seed value every time your software program is started. Keep in mind though that these data storage options have a limited amount of write cycles. A better option might be to use external FRAM. If your microcontroller has access to an external file system such as an SD-card, you could store a value, which you use to seed the generator, in a file. Then simply increment its value by one upon software program startup. This way you have a different seed value every time your software program is started. If your microcontroller based system features a battery backed real-time clock, you could use the current date/time value to seed the generator algorithm. Here are the results of a demo program that implements method (1) with the floating analog input to seed the generator algorithm: Reset #1 Reset #2 Reset #3 1193105914 99986390 2131584566 3607630837 1266123007 2093232 2184628642 3493368727 1164981103 793839531 296055939 3318979929 Examples To generate a new random number, call the function TbxRandomNumberGet() and it will return a new 32-bit random number. Example: uint32_t number; /* Generate a new random number. */ number = TbxRandomNumberGet(); The following function is an example implementation of an application specific seed initialization. It is based on the above described method (1) where a floating analog input provides randomness upon each read of the analog pin: uint32_t CustomSeedInitHandler(void) { /* Create a 32-bit seed value by combining two reads of the floating analog * pin. */ return (AnalogFloatGet() << 16u) | AnalogFloatGet(); } The above example assumes that the application provides the function AnalogFloatGet() for performing an analog to digital conversion of the analog input pin that is left floating. To register the function CustomSeedInitHandler() with the random number generator software component, make the following function call during the initialization of your software program: /* Register application specific seed initialization function. */ TbxRandomSetSeedInitHandler(CustomSeedInitHandler);","title":"Random numbers"},{"location":"random/#random-numbers","text":"The random number generator software component offers functionality for generating 32-bit random numbers. The generator algorithm is based on the linear feedback shift register approach ( LFSR ), specifically the one presented in application note 4400 from Maxim Integrated.","title":"Random numbers"},{"location":"random/#usage","text":"Whenever a random number is to be obtained, call function TbxRandomNumberGet() . The internal generator algorithm needs to be properly seeded. By default, the same constant value is assigned to the seed. This means that each time function TbxRandomNumberGet() is called, you get a different number, but the consecutive numbers will always be the same each time your program is restarted: Reset #1 Reset #2 Reset #3 3196210335 3196210335 3196210335 2375684060 2375684060 2375684060 3691277220 3691277220 3691277220 3596136368 3596136368 3596136368 For some applications, this behavior is acceptable. However, most applications require different random numbers to be generated each time the software program is started. This is achieved by calling TbxRandomSetSeedInitHandler() to register your own seed initialization function. The ideal implementation of your seed initialization function is such that it returns a different seed value, each time the software program is newly started. Here are some possible approaches to realize such a changing seed value: Keep one of the analog inputs on your microcontroller unconnected. Such a floating analog input picks up noise from the surrounding environment and readings will therefore always vary slightly. Configure your ADC peripheral to perform an analog to digital conversion of this analog input and use its result value to seed the generator. If your microcontroller has EEPROM or a non-volatile register, you can use it to store a value that you use to seed the generator. Then simply increment its value by one upon software program startup. This way you have a different seed value every time your software program is started. Keep in mind though that these data storage options have a limited amount of write cycles. A better option might be to use external FRAM. If your microcontroller has access to an external file system such as an SD-card, you could store a value, which you use to seed the generator, in a file. Then simply increment its value by one upon software program startup. This way you have a different seed value every time your software program is started. If your microcontroller based system features a battery backed real-time clock, you could use the current date/time value to seed the generator algorithm. Here are the results of a demo program that implements method (1) with the floating analog input to seed the generator algorithm: Reset #1 Reset #2 Reset #3 1193105914 99986390 2131584566 3607630837 1266123007 2093232 2184628642 3493368727 1164981103 793839531 296055939 3318979929","title":"Usage"},{"location":"random/#examples","text":"To generate a new random number, call the function TbxRandomNumberGet() and it will return a new 32-bit random number. Example: uint32_t number; /* Generate a new random number. */ number = TbxRandomNumberGet(); The following function is an example implementation of an application specific seed initialization. It is based on the above described method (1) where a floating analog input provides randomness upon each read of the analog pin: uint32_t CustomSeedInitHandler(void) { /* Create a 32-bit seed value by combining two reads of the floating analog * pin. */ return (AnalogFloatGet() << 16u) | AnalogFloatGet(); } The above example assumes that the application provides the function AnalogFloatGet() for performing an analog to digital conversion of the analog input pin that is left floating. To register the function CustomSeedInitHandler() with the random number generator software component, make the following function call during the initialization of your software program: /* Register application specific seed initialization function. */ TbxRandomSetSeedInitHandler(CustomSeedInitHandler);","title":"Examples"}]}